<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>RTS con c√°mara, profesiones y enemigos neutrales</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: #1a2a1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #gameContainer {
            background: #2a3a2a;
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.7);
        }
        canvas {
            display: block;
            margin: 0 auto;
            border: 3px solid #6b4e3a;
            border-radius: 8px;
            cursor: crosshair;
        }
        #infoPanel {
            margin-top: 12px;
            color: #e0d8b0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #3b4a3b;
            padding: 8px 16px;
            border-radius: 40px;
            border: 1px solid #8b7a5a;
            flex-wrap: wrap;
        }
        #resources {
            font-size: 1.3rem;
            font-weight: bold;
            text-shadow: 2px 2px 0 #2a3a2a;
            min-width: 200px;
        }
        #selectedInfo {
            background: #4a5a4a;
            padding: 4px 16px;
            border-radius: 30px;
            border: 1px solid #b0a880;
            min-width: 220px;
            text-align: center;
        }
        .botones {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }
        button {
            background: #6b8c5c;
            border: none;
            color: white;
            font-weight: bold;
            padding: 6px 15px;
            border-radius: 30px;
            cursor: pointer;
            border-bottom: 3px solid #3a5a3a;
            transition: 0.1s ease;
            font-size: 0.9rem;
        }
        button:hover {
            background: #7b9c6c;
            border-bottom-width: 1px;
            transform: translateY(2px);
        }
        button:active {
            transform: translateY(4px);
            border-bottom-width: 0;
        }
        button:disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        #profesionesMenu, #cuartelMenu {
            display: flex;
            gap: 5px;
            margin-left: 10px;
        }
        .menuBotones {
            background: #5a6a5a;
            border-radius: 30px;
            padding: 4px 8px;
            display: flex;
            gap: 5px;
        }
    </style>
</head>
<body>
<div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="infoPanel">
        <div id="resources">üå≤ 300  üçñ 150  ‚öîÔ∏è 0  Ronda: 1</div>
        <div id="selectedInfo">üè† Ninguno</div>
        <div class="botones">
            <div id="profesionesMenu" style="display:none;" class="menuBotones">
                <button id="profLenador">ü™ì Le√±ador</button>
                <button id="profMinero">‚õèÔ∏è Minero</button>
                <button id="profRecolector">üåæ Recolector</button>
                <button id="profConstructor">üî® Constructor</button>
            </div>
            <div id="cuartelMenu" style="display:none;" class="menuBotones">
                <button id="trainAldeano">üë®‚Äçüåæ Aldeano (50üå≤)</button>
                <button id="trainSoldado">‚öîÔ∏è Soldado (60üå≤ 40üçñ)</button>
                <button id="trainExplorador">üèπ Explorador (40üå≤ 20üçñ)</button>
            </div>
            <button id="buildBarracksBtn">üèõÔ∏è Construir cuartel (200üå≤)</button>
        </div>
    </div>
</div>

<script>
    // --------------------------------------------------------------
    // CONSTANTES
    // --------------------------------------------------------------
    const CELDA = 20;                // p√≠xeles por celda (m√°s peque√±o para mapa gigante)
    const COLUMNAS = 100;            // mapa ancho
    const FILAS = 100;               // mapa alto
    const ANCHO_VENTANA = 800;
    const ALTO_VENTANA = 600;
    const CELDAS_VISIBLES_X = Math.ceil(ANCHO_VENTANA / CELDA) + 2;
    const CELDAS_VISIBLES_Y = Math.ceil(ALTO_VENTANA / CELDA) + 2;

    // Tipos de terreno
    const TERRENO = {
        TIERRA: 0,
        AGUA: 1,
        BOSQUE: 2,
        MONTA√ëA: 3,
        MINA: 4
    };

    const COLOR_TERRENO = [
        "#6b8e4c", // tierra
        "#3a6ea5", // agua
        "#2d5a2d", // bosque
        "#7a6a5a", // monta√±a
        "#b88a3a"  // mina (nuevo)
    ];

    // --------------------------------------------------------------
    // RECURSOS DEL JUGADOR
    // --------------------------------------------------------------
    let recursos = { madera: 300, comida: 150, piedra: 100, oro: 50 };

    // --------------------------------------------------------------
    // MAPA (matriz de celdas)
    // --------------------------------------------------------------
    let mapa = [];
    function generarMapa() {
        for (let f = 0; f < FILAS; f++) {
            let fila = [];
            for (let c = 0; c < COLUMNAS; c++) {
                let r = Math.random();
                let tipo;
                if (r < 0.5) tipo = TERRENO.TIERRA;
                else if (r < 0.65) tipo = TERRENO.BOSQUE;
                else if (r < 0.8) tipo = TERRENO.AGUA;
                else if (r < 0.9) tipo = TERRENO.MONTA√ëA;
                else tipo = TERRENO.MINA;

                let recurso = null;
                if (tipo === TERRENO.BOSQUE) recurso = { tipo: "madera", cantidad: 100 };
                if (tipo === TERRENO.MINA) recurso = { tipo: "piedra", cantidad: 150 };

                fila.push({
                    tipo: tipo,
                    recurso: recurso,
                    edificio: null,
                    construyendo: null,
                    unidad: null
                });
            }
            mapa.push(fila);
        }
    }
    generarMapa();

    // Posici√≥n inicial del jugador (centro aproximado)
    const CENTRO_JUGADOR_X = 50;
    const CENTRO_JUGADOR_Y = 50;
    mapa[CENTRO_JUGADOR_Y][CENTRO_JUGADOR_X].tipo = TERRENO.TIERRA;
    mapa[CENTRO_JUGADOR_Y][CENTRO_JUGADOR_X].edificio = {
        tipo: "centro",
        salud: 500,
        maxSalud: 500,
        produccion: [],
        equipo: "jugador"
    };

    // Centro enemigo en el otro extremo
    mapa[10][10].tipo = TERRENO.TIERRA;
    mapa[10][10].edificio = {
        tipo: "centro",
        salud: 500,
        maxSalud: 500,
        produccion: [],
        equipo: "enemigo"
    };

    // --------------------------------------------------------------
    // CLASE UNIDAD (movimiento por casillas)
    // --------------------------------------------------------------
    class Unidad {
        constructor(x, y, tipo, hp, ataque, velocidad, equipo, profesion = null) {
            this.x = x;             // entero (celda)
            this.y = y;
            this.tipo = tipo;       // "aldeano", "soldado", "explorador"
            this.profesion = profesion; // para aldeanos
            this.hp = hp;
            this.maxHp = hp;
            this.ataque = ataque;
            this.velocidad = velocidad; // celdas por segundo
            this.equipo = equipo;
            this.destino = null;     // {x, y} en celdas
            this.camino = [];         // lista de {x, y} (pathfinding)
            this.estado = "idle";     // idle, moviendo, atacando, recolectando, construyendo
            this.objetivoAtaque = null;
            this.objetivoRecurso = null;
            this.carga = 0;
            this.capacidadCarga = 20;
            this.tiempoAtaque = 0;
            this.rangoAtaque = (tipo === "soldado" ? 1.5 : (tipo === "explorador" ? 3 : 1));
            this.tiempoMovimiento = 0; // acumulador para movimiento paso a paso
            this.pasoTiempo = 1.0 / this.velocidad; // segundos por celda
            this.hostil = false; // para enemigos: si son neutrales o no
        }

        // Asignar destino (celda entera)
        irA(destX, destY) {
            if (destX < 0 || destX >= COLUMNAS || destY < 0 || destY >= FILAS) return false;
            // Por ahora movimiento directo sin pathfinding (simplificado)
            this.destino = { x: destX, y: destY };
            this.camino = []; // luego implementaremos A*
            this.estado = "moviendo";
            return true;
        }

        // Actualizar movimiento por pasos discretos
        actualizarMovimiento(dt) {
            if (this.estado !== "moviendo" || !this.destino) return;

            this.tiempoMovimiento += dt;
            while (this.tiempoMovimiento >= this.pasoTiempo && this.estado === "moviendo") {
                this.tiempoMovimiento -= this.pasoTiempo;

                // Calcular direcci√≥n hacia el destino
                let dx = this.destino.x - this.x;
                let dy = this.destino.y - this.y;
                if (dx === 0 && dy === 0) {
                    this.estado = "idle";
                    this.destino = null;
                    break;
                }

                // Moverse una celda en la direcci√≥n m√°s adecuada (simple)
                if (Math.abs(dx) > Math.abs(dy)) {
                    this.x += (dx > 0 ? 1 : -1);
                } else {
                    this.y += (dy > 0 ? 1 : -1);
                }

                // Comprobar si lleg√≥
                if (this.x === this.destino.x && this.y === this.destino.y) {
                    this.estado = "idle";
                    this.destino = null;
                    break;
                }
            }
        }

        atacar(objetivo) {
            if (!objetivo) return;
            let dx = objetivo.x - this.x;
            let dy = objetivo.y - this.y;
            let dist = Math.hypot(dx, dy);
            if (dist <= this.rangoAtaque) {
                objetivo.hp -= this.ataque;
                if (objetivo.hp <= 0) {
                    objetivo.morir();
                    this.estado = "idle";
                    this.objetivoAtaque = null;
                }
            } else {
                this.irA(objetivo.x, objetivo.y);
                this.objetivoAtaque = objetivo;
            }
        }

        morir() {
            let lista = (this.equipo === "jugador") ? unidadesJugador : unidadesEnemigo;
            let idx = lista.indexOf(this);
            if (idx !== -1) lista.splice(idx, 1);
            // Limpiar referencia en mapa
            for (let f = 0; f < FILAS; f++) {
                for (let c = 0; c < COLUMNAS; c++) {
                    if (mapa[f][c].unidad === this) mapa[f][c].unidad = null;
                }
            }
        }
    }

    // --------------------------------------------------------------
    // LISTAS DE UNIDADES
    // --------------------------------------------------------------
    let unidadesJugador = [];
    let unidadesEnemigo = [];

    // Crear aldeano inicial
    unidadesJugador.push(new Unidad(50, 50, "aldeano", 25, 2, 2.0, "jugador", "le√±ador"));
    // Crear soldado enemigo neutral (no hostil)
    unidadesEnemigo.push(new Unidad(12, 12, "soldado", 40, 8, 1.5, "enemigo"));

    // --------------------------------------------------------------
    // C√ÅMARA
    // --------------------------------------------------------------
    let camX = 40; // celda superior izquierda
    let camY = 40;
    const teclas = { w: false, a: false, s: false, d: false };

    function actualizarCamara() {
        if (teclas.w) camY = Math.max(0, camY - 1);
        if (teclas.s) camY = Math.min(FILAS - CELDAS_VISIBLES_Y, camY + 1);
        if (teclas.a) camX = Math.max(0, camX - 1);
        if (teclas.d) camX = Math.min(COLUMNAS - CELDAS_VISIBLES_X, camX + 1);
    }

    // --------------------------------------------------------------
    // VARIABLES DE SELECCI√ìN
    // --------------------------------------------------------------
    let unidadSeleccionada = null;
    let edificioSeleccionado = null; // { celda, tipo, equipo }
    let modoConstruccion = null;

    // --------------------------------------------------------------
    // RONDAS Y HOSTILIDAD
    // --------------------------------------------------------------
    let ronda = 1;
    let tiempoRonda = 0;
    const TIEMPO_POR_RONDA = 30; // segundos

    function actualizarRondas(dt) {
        tiempoRonda += dt;
        if (tiempoRonda >= TIEMPO_POR_RONDA) {
            tiempoRonda = 0;
            ronda++;
            if (ronda >= 50) {
                // Todos los enemigos se vuelven hostiles
                unidadesEnemigo.forEach(u => u.hostil = true);
            }
        }
    }

    // Funci√≥n para activar hostilidad en un √°rea
    function activarHostilidadRadio(x, y, radio) {
        unidadesEnemigo.forEach(u => {
            let d = Math.hypot(u.x - x, u.y - y);
            if (d <= radio) u.hostil = true;
        });
    }

    // --------------------------------------------------------------
    // CANVAS Y CONTEXTO
    // --------------------------------------------------------------
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // --------------------------------------------------------------
    // INTERFAZ
    // --------------------------------------------------------------
    const resourcesSpan = document.getElementById('resources');
    const selectedInfoSpan = document.getElementById('selectedInfo');
    const profesionesMenu = document.getElementById('profesionesMenu');
    const cuartelMenu = document.getElementById('cuartelMenu');
    const buildBarracksBtn = document.getElementById('buildBarracksBtn');

    function actualizarUI() {
        resourcesSpan.innerHTML = `üå≤ ${recursos.madera}  üçñ ${recursos.comida}  ‚öîÔ∏è ${unidadesJugador.length}  Ronda: ${ronda}`;

        if (unidadSeleccionada) {
            selectedInfoSpan.innerHTML = `üë§ ${unidadSeleccionada.tipo} (${unidadSeleccionada.hp}/${unidadSeleccionada.maxHp}) Prof: ${unidadSeleccionada.profesion || 'ninguna'}`;
            if (unidadSeleccionada.tipo === "aldeano") {
                profesionesMenu.style.display = "flex";
                cuartelMenu.style.display = "none";
            } else {
                profesionesMenu.style.display = "none";
                cuartelMenu.style.display = "none";
            }
        } else if (edificioSeleccionado) {
            selectedInfoSpan.innerHTML = `üè† ${edificioSeleccionado.tipo} (${edificioSeleccionado.celda.edificio.salud}/${edificioSeleccionado.celda.edificio.maxSalud})`;
            if (edificioSeleccionado.tipo === "cuartel" && edificioSeleccionado.equipo === "jugador") {
                cuartelMenu.style.display = "flex";
                profesionesMenu.style.display = "none";
            } else {
                cuartelMenu.style.display = "none";
                profesionesMenu.style.display = "none";
            }
        } else {
            selectedInfoSpan.innerHTML = `üè† Ninguno`;
            profesionesMenu.style.display = "none";
            cuartelMenu.style.display = "none";
        }
    }

    // --------------------------------------------------------------
    // CONSTRUCCI√ìN DE EDIFICIOS
    // --------------------------------------------------------------
    buildBarracksBtn.addEventListener('click', () => {
        if (recursos.madera >= 200) {
            modoConstruccion = { tipo: "cuartel", costo: 200 };
        } else {
            alert("No tienes suficiente madera (200)");
        }
    });

    function iniciarConstruccion(x, y) {
        if (!modoConstruccion) return false;
        let celda = mapa[y][x];
        if (celda.tipo !== TERRENO.TIERRA || celda.edificio || celda.construyendo) return false;

        recursos.madera -= modoConstruccion.costo;
        celda.construyendo = {
            tipo: modoConstruccion.tipo,
            progreso: 0,
            tiempoTotal: 5.0, // 5 segundos
            equipo: "jugador"
        };
        modoConstruccion = null;
        return true;
    }

    function actualizarConstrucciones(dt) {
        for (let f = 0; f < FILAS; f++) {
            for (let c = 0; c < COLUMNAS; c++) {
                let celda = mapa[f][c];
                if (celda.construyendo) {
                    celda.construyendo.progreso += dt;
                    if (celda.construyendo.progreso >= celda.construyendo.tiempoTotal) {
                        celda.edificio = {
                            tipo: celda.construyendo.tipo,
                            salud: 300,
                            maxSalud: 300,
                            equipo: celda.construyendo.equipo,
                            produccion: []
                        };
                        celda.construyendo = null;
                    }
                }
            }
        }
    }

    // --------------------------------------------------------------
    // ENTRENAMIENTO (men√∫ cuartel)
    // --------------------------------------------------------------
    document.getElementById('trainAldeano').addEventListener('click', () => {
        if (!edificioSeleccionado) return;
        let celda = edificioSeleccionado.celda;
        if (recursos.madera >= 50) {
            recursos.madera -= 50;
            celda.edificio.produccion.push({ tipo: "aldeano", tiempo: 0, total: 4 });
        }
    });
    document.getElementById('trainSoldado').addEventListener('click', () => {
        if (!edificioSeleccionado) return;
        if (recursos.madera >= 60 && recursos.comida >= 40) {
            recursos.madera -= 60;
            recursos.comida -= 40;
            celda.edificio.produccion.push({ tipo: "soldado", tiempo: 0, total: 5 });
        }
    });
    document.getElementById('trainExplorador').addEventListener('click', () => {
        if (!edificioSeleccionado) return;
        if (recursos.madera >= 40 && recursos.comida >= 20) {
            recursos.madera -= 40;
            recursos.comida -= 20;
            celda.edificio.produccion.push({ tipo: "explorador", tiempo: 0, total: 3 });
        }
    });

    function actualizarEntrenamiento(dt) {
        for (let f = 0; f < FILAS; f++) {
            for (let c = 0; c < COLUMNAS; c++) {
                let edificio = mapa[f][c].edificio;
                if (edificio && edificio.produccion && edificio.produccion.length > 0) {
                    let primero = edificio.produccion[0];
                    primero.tiempo += dt;
                    if (primero.tiempo >= primero.total) {
                        let nuevaUnidad;
                        if (primero.tipo === "aldeano") {
                            nuevaUnidad = new Unidad(c, f, "aldeano", 25, 2, 2.0, "jugador", "le√±ador");
                        } else if (primero.tipo === "soldado") {
                            nuevaUnidad = new Unidad(c, f, "soldado", 40, 8, 1.5, "jugador");
                        } else if (primero.tipo === "explorador") {
                            nuevaUnidad = new Unidad(c, f, "explorador", 30, 5, 2.5, "jugador");
                        }
                        unidadesJugador.push(nuevaUnidad);
                        edificio.produccion.shift();
                    }
                }
            }
        }
    }

    // --------------------------------------------------------------
    // PROFESIONES DE ALDEANO
    // --------------------------------------------------------------
    document.getElementById('profLenador').addEventListener('click', () => {
        if (unidadSeleccionada && unidadSeleccionada.tipo === "aldeano") {
            unidadSeleccionada.profesion = "le√±ador";
        }
    });
    document.getElementById('profMinero').addEventListener('click', () => {
        if (unidadSeleccionada && unidadSeleccionada.tipo === "aldeano") {
            unidadSeleccionada.profesion = "minero";
        }
    });
    document.getElementById('profRecolector').addEventListener('click', () => {
        if (unidadSeleccionada && unidadSeleccionada.tipo === "aldeano") {
            unidadSeleccionada.profesion = "recolector";
        }
    });
    document.getElementById('profConstructor').addEventListener('click', () => {
        if (unidadSeleccionada && unidadSeleccionada.tipo === "aldeano") {
            unidadSeleccionada.profesion = "constructor";
        }
    });

    // --------------------------------------------------------------
    // RECOLECCI√ìN POR PROFESI√ìN
    // --------------------------------------------------------------
    function actualizarAldeanos(dt) {
        unidadesJugador.forEach(u => {
            if (u.tipo !== "aldeano") return;

            // Recolecci√≥n seg√∫n profesi√≥n
            if (u.estado === "recolectando" && u.objetivoRecurso) {
                let celda = mapa[u.objetivoRecurso.y][u.objetivoRecurso.x];
                if (!celda.recurso || celda.recurso.cantidad <= 0) {
                    u.estado = "idle";
                    u.objetivoRecurso = null;
                    return;
                }

                // Verificar que la profesi√≥n pueda recolectar ese recurso
                let puede = false;
                if (u.profesion === "le√±ador" && celda.recurso.tipo === "madera") puede = true;
                if (u.profesion === "minero" && celda.recurso.tipo === "piedra") puede = true;
                if (u.profesion === "recolector" && celda.recurso.tipo === "comida") puede = true;
                // Para simplificar, asumimos que hay arbustos de comida (no implementados)
                if (!puede) {
                    u.estado = "idle";
                    return;
                }

                if (!u.recoleccionTimer) u.recoleccionTimer = 0;
                u.recoleccionTimer += dt;
                while (u.recoleccionTimer >= 0.5 && celda.recurso.cantidad > 0 && u.carga < u.capacidadCarga) {
                    u.recoleccionTimer -= 0.5;
                    let recolectado = Math.min(5, celda.recurso.cantidad, u.capacidadCarga - u.carga);
                    celda.recurso.cantidad -= recolectado;
                    u.carga += recolectado;
                }

                if (celda.recurso.cantidad <= 0) celda.recurso = null;

                if (u.carga >= u.capacidadCarga) {
                    u.irA(CENTRO_JUGADOR_X, CENTRO_JUGADOR_Y);
                    u.estado = "moviendo";
                }
            }

            // Depositar en centro
            if (u.estado === "idle" && u.x === CENTRO_JUGADOR_X && u.y === CENTRO_JUGADOR_Y && u.carga > 0) {
                if (u.profesion === "le√±ador") recursos.madera += u.carga;
                if (u.profesion === "minero") recursos.piedra += u.carga;
                if (u.profesion === "recolector") recursos.comida += u.carga;
                u.carga = 0;
            }

            // Buscar recursos si est√° idle
            if (u.estado === "idle" && u.profesion) {
                let tipoBuscado = u.profesion === "le√±ador" ? "madera" : (u.profesion === "minero" ? "piedra" : "comida");
                // Buscar en un radio
                for (let dy = -5; dy <= 5; dy++) {
                    for (let dx = -5; dx <= 5; dx++) {
                        let nx = u.x + dx;
                        let ny = u.y + dy;
                        if (nx >= 0 && nx < COLUMNAS && ny >= 0 && ny < FILAS) {
                            let celda = mapa[ny][nx];
                            if (celda.recurso && celda.recurso.tipo === tipoBuscado) {
                                u.objetivoRecurso = { x: nx, y: ny };
                                u.irA(nx, ny);
                                return;
                            }
                        }
                    }
                }
            }
        });
    }

    // --------------------------------------------------------------
    // IA ENEMIGA (solo hostiles)
    // --------------------------------------------------------------
    function actualizarIAEnemiga(dt) {
        unidadesEnemigo.forEach(enemigo => {
            if (!enemigo.hostil) return; // neutral, no hace nada

            if (enemigo.estado === "atacando" && enemigo.objetivoAtaque) {
                enemigo.atacar(enemigo.objetivoAtaque);
                return;
            }

            // Buscar objetivo jugador
            let objetivo = null;
            let distMin = 1000;

            unidadesJugador.forEach(u => {
                let d = Math.hypot(u.x - enemigo.x, u.y - enemigo.y);
                if (d < distMin) {
                    distMin = d;
                    objetivo = u;
                }
            });

            for (let f = 0; f < FILAS; f++) {
                for (let c = 0; c < COLUMNAS; c++) {
                    let ed = mapa[f][c].edificio;
                    if (ed && ed.equipo === "jugador") {
                        let d = Math.hypot(c - enemigo.x, f - enemigo.y);
                        if (d < distMin) {
                            distMin = d;
                            objetivo = { x: c, y: f, hp: ed.salud, edificio: true };
                        }
                    }
                }
            }

            if (objetivo) {
                enemigo.estado = "atacando";
                enemigo.objetivoAtaque = objetivo;
                enemigo.irA(objetivo.x, objetivo.y);
            }
        });
    }

    // --------------------------------------------------------------
    // COMBATE
    // --------------------------------------------------------------
    function actualizarCombate(dt) {
        // Ataques de enemigos hostiles
        unidadesEnemigo.forEach(e => {
            if (e.hostil && e.estado === "atacando" && e.objetivoAtaque) {
                e.atacar(e.objetivoAtaque);
            }
        });

        // Ataques de jugadores a enemigos
        unidadesJugador.forEach(u => {
            if (u.tipo !== "aldeano" && u.estado === "idle") {
                let enemigoCercano = null;
                let distMin = 5;
                unidadesEnemigo.forEach(e => {
                    let d = Math.hypot(e.x - u.x, e.y - u.y);
                    if (d < distMin && e.hostil) { // solo atacan a hostiles
                        distMin = d;
                        enemigoCercano = e;
                    }
                });
                if (enemigoCercano) {
                    u.estado = "atacando";
                    u.objetivoAtaque = enemigoCercano;
                }
            }
            if (u.estado === "atacando" && u.objetivoAtaque) {
                u.atacar(u.objetivoAtaque);
                // Si atacamos a un enemigo neutral, se vuelve hostil
                if (u.objetivoAtaque.equipo === "enemigo" && !u.objetivoAtaque.hostil) {
                    activarHostilidadRadio(u.objetivoAtaque.x, u.objetivoAtaque.y, 5);
                }
            }
        });

        // Da√±o a edificios
        unidadesEnemigo.forEach(e => {
            if (!e.hostil) return;
            for (let f = 0; f < FILAS; f++) {
                for (let c = 0; c < COLUMNAS; c++) {
                    let ed = mapa[f][c].edificio;
                    if (ed && ed.equipo === "jugador") {
                        let d = Math.hypot(c - e.x, f - e.y);
                        if (d < 1.5) {
                            ed.salud -= e.ataque * dt;
                            if (ed.salud <= 0) mapa[f][c].edificio = null;
                        }
                    }
                }
            }
        });
    }

    // --------------------------------------------------------------
    // DIBUJADO (solo parte visible)
    // --------------------------------------------------------------
    function dibujar() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        let inicioX = camX;
        let inicioY = camY;
        let finX = Math.min(COLUMNAS, camX + CELDAS_VISIBLES_X);
        let finY = Math.min(FILAS, camY + CELDAS_VISIBLES_Y);

        for (let fila = inicioY; fila < finY; fila++) {
            for (let col = inicioX; col < finX; col++) {
                let celda = mapa[fila][col];
                let xCanvas = (col - camX) * CELDA;
                let yCanvas = (fila - camY) * CELDA;

                ctx.fillStyle = COLOR_TERRENO[celda.tipo];
                ctx.fillRect(xCanvas, yCanvas, CELDA-1, CELDA-1);

                // Recursos
                if (celda.recurso) {
                    if (celda.recurso.tipo === "madera") {
                        ctx.fillStyle = "#3c8c3c";
                        ctx.beginPath();
                        ctx.arc(xCanvas + CELDA/2, yCanvas + CELDA/2, 6, 0, 2*Math.PI);
                        ctx.fill();
                    } else if (celda.recurso.tipo === "piedra") {
                        ctx.fillStyle = "#888";
                        ctx.fillRect(xCanvas + 5, yCanvas + 5, 10, 10);
                    }
                }

                // Edificios
                if (celda.edificio) {
                    ctx.fillStyle = celda.edificio.equipo === "jugador" ? "#a52a2a" : "#8b3a3a";
                    ctx.fillRect(xCanvas + 2, yCanvas + 2, CELDA-6, CELDA-6);
                    // Barra de salud
                    let saludPercent = celda.edificio.salud / celda.edificio.maxSalud;
                    ctx.fillStyle = "#0f0";
                    ctx.fillRect(xCanvas + 2, yCanvas - 3, (CELDA-6) * saludPercent, 3);
                }

                // Construcci√≥n
                if (celda.construyendo) {
                    ctx.fillStyle = "#aaa";
                    ctx.fillRect(xCanvas + 2, yCanvas + 2, CELDA-6, CELDA-6);
                    ctx.fillStyle = "#ff0";
                    let progreso = celda.construyendo.progreso / celda.construyendo.tiempoTotal;
                    ctx.fillRect(xCanvas + 2, yCanvas + CELDA-8, (CELDA-6) * progreso, 4);
                }
            }
        }

        // Unidades (dibujar despu√©s)
        function dibujarUnidad(u, color) {
            if (u.x < inicioX || u.x >= finX || u.y < inicioY || u.y >= finY) return;
            let xCanvas = (u.x - camX) * CELDA;
            let yCanvas = (u.y - camY) * CELDA;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(xCanvas + CELDA/2, yCanvas + CELDA/2, 8, 0, 2*Math.PI);
            ctx.fill();
            if (unidadSeleccionada === u) {
                ctx.strokeStyle = "#ffd700";
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(xCanvas + CELDA/2, yCanvas + CELDA/2, 12, 0, 2*Math.PI);
                ctx.stroke();
            }
            // Barra de salud
            ctx.fillStyle = "#0f0";
            ctx.fillRect(xCanvas + 2, yCanvas - 6, 16 * (u.hp / u.maxHp), 3);
        }

        unidadesJugador.forEach(u => dibujarUnidad(u, u.tipo === "aldeano" ? "#f0d880" : "#c04040"));
        unidadesEnemigo.forEach(u => dibujarUnidad(u, u.hostil ? "#a00" : "#6a6a6a")); // gris si neutral

        // Rejilla
        ctx.strokeStyle = "#4a6a4a";
        ctx.lineWidth = 0.5;
        for (let i = 0; i <= CELDAS_VISIBLES_X; i++) {
            ctx.beginPath();
            ctx.moveTo(i * CELDA, 0);
            ctx.lineTo(i * CELDA, canvas.height);
            ctx.stroke();
        }
        for (let i = 0; i <= CELDAS_VISIBLES_Y; i++) {
            ctx.beginPath();
            ctx.moveTo(0, i * CELDA);
            ctx.lineTo(canvas.width, i * CELDA);
            ctx.stroke();
        }
    }

    // --------------------------------------------------------------
    // LOOP PRINCIPAL
    // --------------------------------------------------------------
    let ultimoTiempo = performance.now() / 1000;
    function gameLoop(now) {
        now /= 1000;
        let dt = Math.min(0.1, now - ultimoTiempo);
        ultimoTiempo = now;

        actualizarCamara();
        actualizarRondas(dt);
        actualizarConstrucciones(dt);
        actualizarEntrenamiento(dt);
        actualizarAldeanos(dt);
        actualizarIAEnemiga(dt);
        actualizarCombate(dt);

        // Mover unidades
        [...unidadesJugador, ...unidadesEnemigo].forEach(u => u.actualizarMovimiento(dt));

        // Actualizar ocupaci√≥n en mapa
        for (let f = 0; f < FILAS; f++) {
            for (let c = 0; c < COLUMNAS; c++) {
                mapa[f][c].unidad = null;
            }
        }
        [...unidadesJugador, ...unidadesEnemigo].forEach(u => {
            if (u.x >= 0 && u.x < COLUMNAS && u.y >= 0 && u.y < FILAS) {
                mapa[u.y][u.x].unidad = u;
            }
        });

        dibujar();
        actualizarUI();

        requestAnimationFrame(gameLoop);
    }

    // --------------------------------------------------------------
    // EVENTOS DE TECLADO (WASD)
    // --------------------------------------------------------------
    window.addEventListener('keydown', (e) => {
        switch(e.key.toLowerCase()) {
            case 'w': teclas.w = true; e.preventDefault(); break;
            case 'a': teclas.a = true; e.preventDefault(); break;
            case 's': teclas.s = true; e.preventDefault(); break;
            case 'd': teclas.d = true; e.preventDefault(); break;
        }
    });
    window.addEventListener('keyup', (e) => {
        switch(e.key.toLowerCase()) {
            case 'w': teclas.w = false; e.preventDefault(); break;
            case 'a': teclas.a = false; e.preventDefault(); break;
            case 's': teclas.s = false; e.preventDefault(); break;
            case 'd': teclas.d = false; e.preventDefault(); break;
        }
    });

    // --------------------------------------------------------------
    // EVENTOS DE RAT√ìN
    // --------------------------------------------------------------
    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const mouseX = (e.clientX - rect.left) * scaleX;
        const mouseY = (e.clientY - rect.top) * scaleY;
        const col = Math.floor(mouseX / CELDA) + camX;
        const fila = Math.floor(mouseY / CELDA) + camY;

        if (e.button === 0) { // Izquierdo
            if (modoConstruccion) {
                iniciarConstruccion(col, fila);
                return;
            }

            // Seleccionar unidad del jugador
            let unidad = unidadesJugador.find(u => u.x === col && u.y === fila);
            if (unidad) {
                unidadSeleccionada = unidad;
                edificioSeleccionado = null;
            } else {
                let celda = mapa[fila]?.[col];
                if (celda && celda.edificio && celda.edificio.equipo === "jugador") {
                    edificioSeleccionado = { celda: celda, tipo: celda.edificio.tipo, equipo: "jugador" };
                    unidadSeleccionada = null;
                } else {
                    unidadSeleccionada = null;
                    edificioSeleccionado = null;
                }
            }
        } else if (e.button === 2) { // Derecho: orden
            e.preventDefault();
            if (unidadSeleccionada) {
                unidadSeleccionada.irA(col, fila);
                // Si es aldeano y hay recurso, asignar recolecci√≥n seg√∫n profesi√≥n
                if (unidadSeleccionada.tipo === "aldeano" && mapa[fila] && mapa[fila][col].recurso) {
                    let recurso = mapa[fila][col].recurso;
                    if ((unidadSeleccionada.profesion === "le√±ador" && recurso.tipo === "madera") ||
                        (unidadSeleccionada.profesion === "minero" && recurso.tipo === "piedra")) {
                        unidadSeleccionada.objetivoRecurso = { x: col, y: fila };
                    }
                }
            }
        }
    });

    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    // Iniciar
    requestAnimationFrame(gameLoop);
</script>
</body>
</html>
