<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Juego tipo Roblox P2P con editor</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #2b2b2b;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            border: 2px solid #555;
            background: #1a1a1a;
            cursor: crosshair;
        }
        #panel {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            justify-content: center;
            background: #3a3a3a;
            padding: 15px;
            border-radius: 8px;
            max-width: 600px;
        }
        input, button {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
        }
        input {
            background: #555;
            color: #fff;
            width: 150px;
        }
        button {
            background: #4CAF50;
            color: white;
            cursor: pointer;
            font-weight: bold;
        }
        button:hover {
            background: #45a049;
        }
        #estado {
            margin-top: 10px;
            font-size: 14px;
            color: #ffd700;
        }
        .info {
            background: #444;
            padding: 5px 10px;
            border-radius: 4px;
        }
        label {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #modo-editor {
            accent-color: #4CAF50;
        }
    </style>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
</head>
<body>
    <h1>üèóÔ∏è Juego tipo Roblox - P2P con Nametags y Editor</h1>
    <canvas id="gameCanvas" width="500" height="500"></canvas>

    <div id="panel">
        <input type="text" id="nombre" placeholder="Tu nombre" value="Jugador" maxlength="15">
        <button id="crearSala">üéÆ Crear Sala</button>
        <input type="text" id="idSala" placeholder="ID de sala a unir">
        <button id="unirSala">üîó Unirse a Sala</button>
        <div class="info" id="miId">ID local: -</div>
        <label>
            <input type="checkbox" id="modo-editor"> ‚úèÔ∏è Modo editor (clic en mapa)
        </label>
    </div>

    <div id="estado">Esperando conexi√≥n...</div>

    <script>
        // ---------- Configuraci√≥n ----------
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const CELL_SIZE = 25;            // 20x20 celdas
        const GRID_SIZE = 20;

        // Estado del juego
        let map = [];                     // 0 = suelo, 1 = muro
        let localPlayer = {
            id: null,
            name: 'Jugador',
            x: 5,                          // posici√≥n inicial por defecto
            y: 5,
            color: '#4287f5'
        };
        let remotePlayers = [];            // jugadores remotos
        let peer = null;
        let conn = null;                   // conexi√≥n activa (solo para el que se une)
        let isHost = false;                 // ¬øsoy el host?

        // Interfaz
        const nombreInput = document.getElementById('nombre');
        const crearBtn = document.getElementById('crearSala');
        const unirBtn = document.getElementById('unirSala');
        const idSalaInput = document.getElementById('idSala');
        const miIdDiv = document.getElementById('miId');
        const estadoDiv = document.getElementById('estado');
        const modoEditorCheck = document.getElementById('modo-editor');

        // Inicializar mapa con algunos muros de ejemplo
        function initMap() {
            for (let i = 0; i < GRID_SIZE; i++) {
                map[i] = [];
                for (let j = 0; j < GRID_SIZE; j++) {
                    map[i][j] = 0; // vac√≠o
                }
            }
            // Paredes alrededor
            for (let i = 0; i < GRID_SIZE; i++) {
                map[0][i] = 1;
                map[GRID_SIZE-1][i] = 1;
                map[i][0] = 1;
                map[i][GRID_SIZE-1] = 1;
            }
            // Algunos obst√°culos internos
            map[5][5] = 1; map[5][6] = 1; map[6][5] = 1;
            map[10][10] = 1; map[10][11] = 1; map[11][10] = 1;
            map[15][3] = 1; map[15][4] = 1; map[16][3] = 1;
        }
        initMap();

        // ---------- Utilidades ----------
        function buscarPosicionLibre() {
            for (let y = 1; y < GRID_SIZE-1; y++) {
                for (let x = 1; x < GRID_SIZE-1; x++) {
                    if (map[y][x] === 0 && !hayJugadorEn(x, y)) {
                        return { x, y };
                    }
                }
            }
            return { x: 5, y: 5 }; // fallback
        }

        function hayJugadorEn(x, y, ignorarId = null) {
            if (localPlayer.x === x && localPlayer.y === y && localPlayer.id !== ignorarId) return true;
            for (let p of remotePlayers) {
                if (p.x === x && p.y === y && p.id !== ignorarId) return true;
            }
            return false;
        }

        // Enviar mensaje a todos los peers (solo hay uno en este ejemplo)
        function enviarMensaje(tipo, datos) {
            if (conn && conn.open) {
                conn.send({ tipo, datos });
            } else if (peer && isHost) {
                // El host puede tener m√∫ltiples conexiones, pero aqu√≠ solo una
                if (peer.connections && Object.values(peer.connections).length > 0) {
                    const firstConn = Object.values(peer.connections)[0][0];
                    if (firstConn.open) {
                        firstConn.send({ tipo, datos });
                    }
                }
            }
        }

        // ---------- Actualizar mapa desde mensaje ----------
        function aplicarMapaCompleto(nuevoMapa) {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    map[y][x] = nuevoMapa[y][x];
                }
            }
        }

        // ---------- Dibujado ----------
        function dibujar() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Dibujar mapa
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    if (map[row][col] === 1) {
                        ctx.fillStyle = '#8B5A2B'; // marr√≥n para muros
                        ctx.fillRect(col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE-1, CELL_SIZE-1);
                    } else {
                        ctx.fillStyle = '#3d3d3d';
                        ctx.fillRect(col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE-1, CELL_SIZE-1);
                        ctx.strokeStyle = '#555';
                        ctx.strokeRect(col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE-1, CELL_SIZE-1);
                    }
                }
            }

            // Dibujar jugadores remotos
            remotePlayers.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x * CELL_SIZE, p.y * CELL_SIZE, CELL_SIZE-2, CELL_SIZE-2);
                // Nametag
                ctx.fillStyle = '#fff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(p.name, p.x * CELL_SIZE + CELL_SIZE/2, p.y * CELL_SIZE - 5);
            });

            // Dibujar jugador local
            ctx.fillStyle = localPlayer.color;
            ctx.fillRect(localPlayer.x * CELL_SIZE, localPlayer.y * CELL_SIZE, CELL_SIZE-2, CELL_SIZE-2);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(localPlayer.name, localPlayer.x * CELL_SIZE + CELL_SIZE/2, localPlayer.y * CELL_SIZE - 5);
        }

        // ---------- Movimiento local ----------
        function moverLocal(dx, dy) {
            let nx = localPlayer.x + dx;
            let ny = localPlayer.y + dy;
            if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) return;
            if (map[ny][nx] === 1) return; // muro
            if (hayJugadorEn(nx, ny, localPlayer.id)) return; // otro jugador

            localPlayer.x = nx;
            localPlayer.y = ny;
            enviarMensaje('move', { x: nx, y: ny });
            dibujar();
        }

        // ---------- Eventos de teclado ----------
        window.addEventListener('keydown', (e) => {
            if (e.key.startsWith('Arrow') || ['w','a','s','d'].includes(e.key.toLowerCase())) {
                e.preventDefault();
                if (!conn && !isHost) {
                    estadoDiv.innerText = 'No hay conexi√≥n P2P activa.';
                    return;
                }
                let dx = 0, dy = 0;
                switch(e.key.toLowerCase()) {
                    case 'arrowright': case 'd': dx = 1; break;
                    case 'arrowleft': case 'a': dx = -1; break;
                    case 'arrowdown': case 's': dy = 1; break;
                    case 'arrowup': case 'w': dy = -1; break;
                }
                moverLocal(dx, dy);
            }
        });

        // ---------- Editor de mapas (clic) ----------
        canvas.addEventListener('click', (e) => {
            if (!modoEditorCheck.checked) return;
            if (!conn && !isHost) {
                estadoDiv.innerText = 'Con√©ctate para editar el mapa.';
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const mouseX = (e.clientX - rect.left) * scaleX;
            const mouseY = (e.clientY - rect.top) * scaleY;

            const col = Math.floor(mouseX / CELL_SIZE);
            const row = Math.floor(mouseY / CELL_SIZE);

            if (col < 0 || col >= GRID_SIZE || row < 0 || row >= GRID_SIZE) return;

            // No permitir colocar muro sobre un jugador
            if (hayJugadorEn(col, row)) {
                estadoDiv.innerText = 'No puedes editar sobre un jugador.';
                return;
            }

            // Cambiar celda
            map[row][col] = map[row][col] === 0 ? 1 : 0;
            dibujar();

            // Enviar actualizaci√≥n al peer
            enviarMensaje('mapUpdate', { x: col, y: row, valor: map[row][col] });
        });

        // ---------- Configurar Peer (Host) ----------
        function crearSala() {
            if (peer) peer.destroy();
            peer = new Peer(); // genera ID aleatorio

            peer.on('open', (id) => {
                isHost = true;
                localPlayer.name = nombreInput.value.trim() || 'Anfitri√≥n';
                localPlayer.id = id;
                miIdDiv.innerText = `ID local: ${id}`;
                estadoDiv.innerText = 'Sala creada. Esperando a que alguien se una...';
                // Buscar posici√≥n libre
                let pos = buscarPosicionLibre();
                localPlayer.x = pos.x;
                localPlayer.y = pos.y;
                dibujar();
            });

            peer.on('connection', (connection) => {
                conn = connection;
                estadoDiv.innerText = '¬°Jugador conectado!';
                conn.on('data', (data) => {
                    procesarMensaje(data, conn);
                });
                conn.on('close', () => {
                    estadoDiv.innerText = 'El otro jugador se desconect√≥.';
                    remotePlayers = [];
                    dibujar();
                });

                // Enviar mapa completo al nuevo cliente (para sincronizar)
                conn.send({ tipo: 'mapFull', datos: map });

                // Enviar tambi√©n nuestro jugador local para que aparezca
                conn.send({ tipo: 'playerJoin', datos: { 
                    id: localPlayer.id, 
                    name: localPlayer.name, 
                    x: localPlayer.x, 
                    y: localPlayer.y,
                    color: localPlayer.color 
                }});
            });

            peer.on('error', (err) => {
                console.error(err);
                estadoDiv.innerText = 'Error en Peer: ' + err.type;
            });
        }

        // ---------- Unirse a sala (Cliente) ----------
        function unirseSala() {
            const hostId = idSalaInput.value.trim();
            if (!hostId) {
                estadoDiv.innerText = 'Ingresa un ID de sala v√°lido.';
                return;
            }
            if (peer) peer.destroy();
            peer = new Peer();

            peer.on('open', (id) => {
                localPlayer.id = id;
                localPlayer.name = nombreInput.value.trim() || 'Invitado';
                miIdDiv.innerText = `ID local: ${id}`;
                estadoDiv.innerText = 'Conectando...';
            });

            peer.on('error', (err) => {
                console.error(err);
                estadoDiv.innerText = 'Error en Peer: ' + err.type;
            });

            // Conectar al host
            conn = peer.connect(hostId);
            conn.on('open', () => {
                estadoDiv.innerText = 'Conectado al host.';
                isHost = false;
                // Enviar nuestros datos al host
                let pos = buscarPosicionLibre();
                localPlayer.x = pos.x;
                localPlayer.y = pos.y;
                conn.send({ tipo: 'playerJoin', datos: { 
                    id: localPlayer.id, 
                    name: localPlayer.name, 
                    x: localPlayer.x, 
                    y: localPlayer.y,
                    color: localPlayer.color 
                }});
            });

            conn.on('data', (data) => {
                procesarMensaje(data, conn);
            });

            conn.on('close', () => {
                estadoDiv.innerText = 'Desconectado del host.';
                remotePlayers = [];
                dibujar();
            });
        }

        // ---------- Procesar mensajes entrantes ----------
        function procesarMensaje(msg, connection) {
            if (!msg || !msg.tipo) return;

            switch (msg.tipo) {
                case 'mapFull':
                    // Recibir mapa completo (solo ocurre al unirse)
                    aplicarMapaCompleto(msg.datos);
                    dibujar();
                    break;
                case 'mapUpdate':
                    // Actualizar una celda
                    let { x, y, valor } = msg.datos;
                    if (x >=0 && x<GRID_SIZE && y>=0 && y<GRID_SIZE) {
                        map[y][x] = valor;
                        dibujar();
                    }
                    break;
                case 'playerJoin':
                    // Nuevo jugador remoto
                    let nuevoJugador = msg.datos;
                    // Evitar duplicados
                    let existe = remotePlayers.find(p => p.id === nuevoJugador.id);
                    if (!existe && nuevoJugador.id !== localPlayer.id) {
                        remotePlayers.push(nuevoJugador);
                        dibujar();
                    }
                    break;
                case 'move':
                    // Movimiento de jugador remoto
                    let { x: mx, y: my } = msg.datos;
                    // Buscar por id? En este ejemplo simple, asumimos que solo hay un remoto y actualizamos sus coordenadas.
                    // Pero podemos mejorar: enviar tambi√©n id. Para simplificar, actualizamos el primer (y √∫nico) remoto.
                    if (remotePlayers.length > 0) {
                        remotePlayers[0].x = mx;
                        remotePlayers[0].y = my;
                    }
                    dibujar();
                    break;
                default:
                    console.log('Mensaje no reconocido', msg);
            }
        }

        // ---------- Inicializar eventos de UI ----------
        crearBtn.addEventListener('click', crearSala);
        unirBtn.addEventListener('click', unirseSala);

        // Primer dibujo
        dibujar();

        // Prevenir que las teclas de flecha muevan la p√°gina
        window.addEventListener('keydown', (e) => {
            if (e.key.startsWith('Arrow')) e.preventDefault();
        }, { passive: false });
    </script>
</body>
</html>
