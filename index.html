<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>RPG 2D Multijugador P2P - Inventario y mapa gigante</title>
    <style>
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #1a1a2e;
            color: white;
            font-family: Arial, sans-serif;
        }
        #gameContainer {
            display: flex;
            gap: 20px;
            margin: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        canvas {
            border: 2px solid #0f3460;
            background: #16213e;
            cursor: crosshair;
        }
        .panel {
            background: #0f3460;
            padding: 15px;
            border-radius: 10px;
            min-width: 250px;
        }
        .panel h3 {
            margin-top: 0;
            color: #e94560;
        }
        .controls {
            margin: 10px 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        button {
            background: #e94560;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
        }
        button:hover {
            background: #ff6b8b;
        }
        button.secondary {
            background: #0f3460;
            border: 1px solid #e94560;
        }
        input, select {
            padding: 5px;
            border-radius: 5px;
            border: none;
        }
        .inventory-list {
            list-style: none;
            padding: 0;
            max-height: 200px;
            overflow-y: auto;
        }
        .inventory-list li {
            background: #16213e;
            margin: 5px 0;
            padding: 5px;
            border-radius: 3px;
        }
        .peer-section {
            border-top: 1px solid #e94560;
            padding-top: 10px;
            margin-top: 10px;
        }
        #status {
            font-size: 12px;
            color: #aaf0e9;
        }
    </style>
    <!-- Incluimos PeerJS -->
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>
</head>
<body>
    <h1>üåü RPG 2D P2P - Inventario + Mapa redimensionable</h1>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="800"></canvas>
        
        <div class="panel">
            <h3>üë§ Jugador local</h3>
            <div class="controls">
                <label>Nametag: <input type="text" id="nameInput" value="Aventurero" maxlength="20"></label>
                <label>üéÆ Tama√±o mapa (N x N): 
                    <input type="range" id="mapSizeSlider" min="5" max="100" value="15" step="1">
                    <span id="mapSizeValue">15</span>
                </label>
                <button id="resizeBtn">üîÑ Redimensionar y reiniciar</button>
                <button id="editorBtn" class="secondary">‚úèÔ∏è Modo Editor: OFF</button>
            </div>

            <div class="peer-section">
                <h3>üåê Multijugador P2P</h3>
                <div>
                    <button id="startPeerBtn">üü¢ Iniciar Peer</button>
                    <span id="peerIdDisplay">-</span>
                </div>
                <div style="margin-top: 5px;">
                    <input type="text" id="peerConnectInput" placeholder="ID del otro jugador">
                    <button id="connectBtn">üîó Conectar</button>
                </div>
                <div id="status">Desconectado</div>
            </div>

            <h3>üéí Inventario</h3>
            <ul class="inventory-list" id="inventoryList">
                <li>Vac√≠o</li>
            </ul>
        </div>
    </div>

    <script>
        // ---------- Configuraci√≥n global ----------
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let MAP_SIZE = 15;                // valor inicial
        let TILE_SIZE = 800 / MAP_SIZE;   // se recalcula al redimensionar

        // Matriz del mapa: 0 = suelo, 1 = pared
        let map = [];

        // Objetos (items) en el mapa: cada objeto tiene {x, y, type}
        let items = [];
        const ITEM_TYPES = ['‚òÖ', '‚öîÔ∏è', 'üß™']; // se usar√° el primero para dibujar

        // Inventario del jugador local
        let inventory = [];

        // Jugador local
        let player = {
            x: 5,
            y: 5,
            name: "Aventurero",
            color: '#e94560'  // rojo
        };

        // Jugador remoto (solo uno por simplicidad)
        let remotePlayer = {
            x: 0,
            y: 0,
            name: "Remoto",
            color: '#4a90e2',  // azul
            connected: false
        };

        // Editor
        let editorMode = false;

        // Elementos DOM
        const nameInput = document.getElementById('nameInput');
        const editorBtn = document.getElementById('editorBtn');
        const mapSizeSlider = document.getElementById('mapSizeSlider');
        const mapSizeValue = document.getElementById('mapSizeValue');
        const resizeBtn = document.getElementById('resizeBtn');
        const inventoryList = document.getElementById('inventoryList');
        const peerIdDisplay = document.getElementById('peerIdDisplay');
        const statusDiv = document.getElementById('status');
        const startPeerBtn = document.getElementById('startPeerBtn');
        const connectBtn = document.getElementById('connectBtn');
        const peerConnectInput = document.getElementById('peerConnectInput');

        // ---------- PeerJS ----------
        let peer = null;
        let conn = null;
        let myPeerId = null;

        // Inicializar Peer (genera ID aleatorio)
        function initPeer() {
            if (peer) peer.destroy();
            peer = new Peer(); // genera ID aleatorio
            peer.on('open', (id) => {
                myPeerId = id;
                peerIdDisplay.textContent = id;
                statusDiv.textContent = 'Peer activo, esperando conexi√≥n...';
            });
            peer.on('connection', (connection) => {
                conn = connection;
                setupConnection(conn);
            });
            peer.on('error', (err) => {
                console.error(err);
                statusDiv.textContent = 'Error: ' + err.type;
            });
        }

        // Configurar conexi√≥n una vez establecida
        function setupConnection(connection) {
            conn = connection;
            statusDiv.textContent = 'Conectado a: ' + connection.peer;
            connection.on('data', (data) => {
                // Procesar mensajes entrantes
                handlePeerData(data);
            });
            connection.on('close', () => {
                statusDiv.textContent = 'Conexi√≥n cerrada';
                remotePlayer.connected = false;
                draw();
            });
            // Enviar nuestro estado actual al conectarnos
            sendFullState();
        }

        // Enviar estado completo al otro jugador
        function sendFullState() {
            if (conn && conn.open) {
                conn.send({
                    type: 'fullState',
                    map: map,
                    items: items,
                    player: { x: player.x, y: player.y, name: player.name },
                    inventory: inventory
                });
            }
        }

        // Manejar datos entrantes
        function handlePeerData(data) {
            switch (data.type) {
                case 'fullState':
                    // Recibimos el mapa, items y posici√≥n del otro
                    if (data.map) map = data.map; // sincronizar mapa (opcional, podr√≠a ser conflicto)
                    if (data.items) items = data.items;
                    if (data.player) {
                        remotePlayer.x = data.player.x;
                        remotePlayer.y = data.player.y;
                        remotePlayer.name = data.player.name;
                        remotePlayer.connected = true;
                    }
                    // Opcional: sincronizar inventario? No, cada quien su inventario.
                    draw();
                    break;
                case 'move':
                    // Otro jugador se movi√≥
                    remotePlayer.x = data.x;
                    remotePlayer.y = data.y;
                    remotePlayer.name = data.name;
                    remotePlayer.connected = true;
                    draw();
                    break;
                case 'mapEdit':
                    // Editar un tile
                    if (data.row !== undefined && data.col !== undefined) {
                        map[data.row][data.col] = data.value;
                        draw();
                    }
                    break;
                case 'itemPickup':
                    // Alguien recogi√≥ un item (sincronizar eliminaci√≥n)
                    if (data.itemIndex !== undefined) {
                        items.splice(data.itemIndex, 1);
                        draw();
                    }
                    break;
                case 'inventoryUpdate':
                    // Podr√≠amos sincronizar inventarios, pero no necesario
                    break;
            }
        }

        // Enviar movimiento
        function sendMove() {
            if (conn && conn.open) {
                conn.send({
                    type: 'move',
                    x: player.x,
                    y: player.y,
                    name: player.name
                });
            }
        }

        // Enviar edici√≥n de mapa
        function sendMapEdit(row, col, value) {
            if (conn && conn.open) {
                conn.send({
                    type: 'mapEdit',
                    row: row,
                    col: col,
                    value: value
                });
            }
        }

        // Enviar recolecci√≥n de item
        function sendItemPickup(index) {
            if (conn && conn.open) {
                conn.send({
                    type: 'itemPickup',
                    itemIndex: index
                });
            }
        }

        // ---------- Funciones del mapa ----------
        function initMap(size) {
            MAP_SIZE = size;
            TILE_SIZE = 800 / MAP_SIZE;

            // Crear matriz vac√≠a (todo suelo)
            map = [];
            for (let i = 0; i < MAP_SIZE; i++) {
                map[i] = [];
                for (let j = 0; j < MAP_SIZE; j++) {
                    map[i][j] = 0;
                }
            }
            // Bordes como paredes
            for (let i = 0; i < MAP_SIZE; i++) {
                map[0][i] = 1;
                map[MAP_SIZE-1][i] = 1;
                map[i][0] = 1;
                map[i][MAP_SIZE-1] = 1;
            }
            // Algunas paredes internas aleatorias (10%)
            for (let i = 2; i < MAP_SIZE-2; i++) {
                for (let j = 2; j < MAP_SIZE-2; j++) {
                    if (Math.random() < 0.1) {
                        map[i][j] = 1;
                    }
                }
            }
            // Asegurar espacio para el jugador
            player.x = Math.floor(MAP_SIZE/2);
            player.y = Math.floor(MAP_SIZE/2);
            map[player.y][player.x] = 0;

            // Generar items aleatorios (10% de celdas de suelo)
            items = [];
            for (let i = 1; i < MAP_SIZE-1; i++) {
                for (let j = 1; j < MAP_SIZE-1; j++) {
                    if (map[i][j] === 0 && Math.random() < 0.05) { // 5% de probabilidad
                        items.push({ x: j, y: i, type: ITEM_TYPES[0] });
                    }
                }
            }
        }

        // Redimensionar mapa desde el slider
        function resizeMap() {
            let newSize = parseInt(mapSizeSlider.value);
            initMap(newSize);
            // Reiniciar inventario local (opcional)
            inventory = [];
            updateInventoryDisplay();
            if (conn && conn.open) {
                sendFullState(); // enviar nuevo estado al otro
            }
            draw();
        }

        // ---------- Dibujado ----------
        function draw() {
            ctx.clearRect(0, 0, 800, 800);

            // Dibujar tiles
            for (let row = 0; row < MAP_SIZE; row++) {
                for (let col = 0; col < MAP_SIZE; col++) {
                    let x = col * TILE_SIZE;
                    let y = row * TILE_SIZE;

                    // Color seg√∫n tipo
                    if (map[row][col] === 0) {
                        ctx.fillStyle = '#4caf50';   // suelo verde
                    } else {
                        ctx.fillStyle = '#9e9e9e';   // pared gris
                    }
                    ctx.fillRect(x, y, TILE_SIZE - 1, TILE_SIZE - 1);

                    // Borde
                    ctx.strokeStyle = '#555';
                    ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
                }
            }

            // Dibujar items
            ctx.font = `${TILE_SIZE * 0.6}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'gold';
            items.forEach(item => {
                let x = item.x * TILE_SIZE + TILE_SIZE/2;
                let y = item.y * TILE_SIZE + TILE_SIZE/2;
                ctx.fillText(item.type, x, y);
            });

            // Dibujar jugador remoto si conectado
            if (remotePlayer.connected) {
                let rx = remotePlayer.x * TILE_SIZE + TILE_SIZE/2;
                let ry = remotePlayer.y * TILE_SIZE + TILE_SIZE/2;
                ctx.beginPath();
                ctx.arc(rx, ry, TILE_SIZE/3, 0, 2*Math.PI);
                ctx.fillStyle = remotePlayer.color;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                // Nametag
                ctx.font = `bold ${TILE_SIZE/4}px Arial`;
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                ctx.textAlign = 'center';
                ctx.strokeText(remotePlayer.name, rx, ry - TILE_SIZE/2 - 2);
                ctx.fillText(remotePlayer.name, rx, ry - TILE_SIZE/2 - 2);
            }

            // Dibujar jugador local
            let px = player.x * TILE_SIZE + TILE_SIZE/2;
            let py = player.y * TILE_SIZE + TILE_SIZE/2;
            ctx.beginPath();
            ctx.arc(px, py, TILE_SIZE/3, 0, 2*Math.PI);
            ctx.fillStyle = player.color;
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            // Nametag local
            ctx.font = `bold ${TILE_SIZE/4}px Arial`;
            ctx.fillStyle = 'white';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 3;
            ctx.textAlign = 'center';
            ctx.strokeText(player.name, px, py - TILE_SIZE/2 - 2);
            ctx.fillText(player.name, px, py - TILE_SIZE/2 - 2);
        }

        // Actualizar lista de inventario en el DOM
        function updateInventoryDisplay() {
            if (inventory.length === 0) {
                inventoryList.innerHTML = '<li>Vac√≠o</li>';
            } else {
                inventoryList.innerHTML = inventory.map((item, i) => `<li>${item} (${i+1})</li>`).join('');
            }
        }

        // Recoger item si el jugador est√° sobre uno
        function pickupItemAt(x, y) {
            for (let i = items.length - 1; i >= 0; i--) {
                if (items[i].x === x && items[i].y === y) {
                    let item = items[i].type;
                    inventory.push(item);
                    items.splice(i, 1);
                    updateInventoryDisplay();
                    sendItemPickup(i);
                    draw();
                    break;
                }
            }
        }

        // ---------- Movimiento local ----------
        function tryMove(dx, dy) {
            let newX = player.x + dx;
            let newY = player.y + dy;
            if (newX < 0 || newX >= MAP_SIZE || newY < 0 || newY >= MAP_SIZE) return false;
            if (map[newY][newX] === 1) return false; // pared

            player.x = newX;
            player.y = newY;
            pickupItemAt(newX, newY); // recoger autom√°tico
            sendMove();
            draw();
            return true;
        }

        // ---------- Eventos ----------
        document.addEventListener('keydown', (e) => {
            if (editorMode) return;
            switch(e.key) {
                case 'w': tryMove(0, -1); break;
                case 's': tryMove(0, 1); break;
                case 'a': tryMove(-1, 0); break;
                case 'd': tryMove(1, 0); break;
            }
        });

        // Editor: clics en canvas
        canvas.addEventListener('mousedown', (e) => {
            if (!editorMode) return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mouseX = (e.clientX - rect.left) * scaleX;
            const mouseY = (e.clientY - rect.top) * scaleY;
            const col = Math.floor(mouseX / TILE_SIZE);
            const row = Math.floor(mouseY / TILE_SIZE);
            if (row >= 0 && row < MAP_SIZE && col >= 0 && col < MAP_SIZE) {
                let value = (e.button === 0) ? 1 : 0; // izq pared, der suelo
                map[row][col] = value;
                sendMapEdit(row, col, value);
                draw();
            }
        });
        canvas.addEventListener('contextmenu', e => e.preventDefault());

        // Bot√≥n editor
        editorBtn.addEventListener('click', () => {
            editorMode = !editorMode;
            editorBtn.textContent = editorMode ? "‚úèÔ∏è Modo Editor: ON" : "‚úèÔ∏è Modo Editor: OFF";
        });

        // Nametag
        nameInput.addEventListener('input', (e) => {
            player.name = e.target.value || "Jugador";
            draw();
        });

        // Slider tama√±o
        mapSizeSlider.addEventListener('input', (e) => {
            mapSizeValue.textContent = e.target.value;
        });
        resizeBtn.addEventListener('click', resizeMap);

        // PeerJS
        startPeerBtn.addEventListener('click', initPeer);
        connectBtn.addEventListener('click', () => {
            let remoteId = peerConnectInput.value.trim();
            if (!remoteId || !peer) {
                alert('Primero inicia Peer o escribe un ID v√°lido');
                return;
            }
            conn = peer.connect(remoteId);
            conn.on('open', () => {
                setupConnection(conn);
            });
            conn.on('error', (err) => {
                statusDiv.textContent = 'Error conexi√≥n: ' + err;
            });
        });

        // Inicializar mapa por defecto
        initMap(15);
        draw();
        updateInventoryDisplay();
    </script>
</body>
</html>
