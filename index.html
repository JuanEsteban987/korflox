<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Roblox Clone P2P - Fixed</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #1a1a1a; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .panel { pointer-events: auto; background: rgba(0,0,0,0.85); color: white; padding: 20px; border-radius: 10px; }
        
        /* Menú Principal */
        #main-menu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 350px; text-align: center; }
        
        /* Código de Sala (Esquina) */
        #room-info { position: absolute; top: 10px; left: 10px; background: rgba(0,255,0,0.2); padding: 10px; border: 1px solid #2ecc71; display: none; pointer-events: auto; }
        
        /* Editor e Interfaz */
        #editor-controls { position: absolute; top: 20px; right: 20px; display: none; }
        #game-ui { position: absolute; bottom: 20px; left: 20px; display: none; }
        
        button { cursor: pointer; padding: 10px; margin: 5px; border: none; border-radius: 5px; font-weight: bold; }
        .btn-green { background: #2ecc71; color: white; }
        .btn-blue { background: #3498db; color: white; }
        input { padding: 8px; border-radius: 5px; margin-bottom: 10px; width: 80%; }
        
        #instructions { font-size: 12px; color: #aaa; margin-top: 10px; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="room-info" class="panel">
            <small>ID DE TU MUNDO:</small>
            <div id="my-id" style="font-weight: bold; color: #2ecc71;">Cargando...</div>
        </div>

        <div id="main-menu" class="panel">
            <h1>BLOCK CRAFT P2P</h1>
            <button class="btn-blue" style="width:100%" onclick="openEditor()">1. CREAR / EDITAR MAPA</button>
            <hr>
            <input type="file" id="map-upload" accept=".json" style="display:none" onchange="handleMapUpload(event)">
            <button class="btn-green" style="width:100%" onclick="document.getElementById('map-upload').click()">2. CARGAR MAPA (.JSON)</button>
            <br><br>
            <input type="text" id="peer-id-input" placeholder="ID de amigo para unirse...">
            <button class="btn-blue" onclick="connectToPeer()">UNIRSE A PARTIDA</button>
            <hr>
            <button id="play-btn" class="btn-green" style="width:100%; font-size: 1.2em;" disabled onclick="startPlayMode()">¡JUGAR AHORA!</button>
        </div>

        <div id="editor-controls" class="panel">
            <h3>MODO EDITOR</h3>
            <p id="instructions">Haz CLICK en el suelo para poner bloques</p>
            <button class="btn-green" onclick="exportMap()">GUARDAR Y EXPORTAR</button>
            <button onclick="location.reload()">VOLVER</button>
        </div>

        <div id="game-ui">
            <div id="chat-box" style="background: rgba(0,0,0,0.5); height: 100px; width: 250px; overflow-y: auto; margin-bottom:5px;"></div>
            <input type="text" id="chat-input" placeholder="Presiona Enter para chat..." style="pointer-events: auto; width: 240px;">
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.3.1/dist/peerjs.min.js"></script>

    <script>
        let scene, camera, renderer, player, clock, raycaster, mouse;
        let mapData = [];
        let isEditor = false, isPlaying = false;
        let peer, conn;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;

        // Inicializar PeerJS (P2P)
        peer = new Peer();
        peer.on('open', (id) => {
            document.getElementById('my-id').innerText = id;
        });

        function initBase() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(5, 10, 7.5);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0x404040));

            // Suelo para el editor
            const groundGeo = new THREE.PlaneGeometry(100, 100);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.name = "suelo";
            scene.add(ground);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            clock = new THREE.Clock();
        }

        // --- EDITOR: COLOCACIÓN MANUAL ---
        function openEditor() {
            isEditor = true;
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('editor-controls').style.display = 'block';
            initBase();
            camera.position.set(20, 20, 20);
            camera.lookAt(0, 0, 0);

            window.addEventListener('mousedown', onEditorClick);
        }

        function onEditorClick(event) {
            if (!isEditor) return;
            // Calcular posición del mouse
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children);

            if (intersects.length > 0) {
                const point = intersects[0].point;
                const bx = Math.round(point.x / 2) * 2;
                const bz = Math.round(point.z / 2) * 2;
                
                const geo = new THREE.BoxGeometry(2, 2, 2);
                const mat = new THREE.MeshStandardMaterial({ color: 0x2ecc71 });
                const block = new THREE.Mesh(geo, mat);
                block.position.set(bx, 1, bz);
                scene.add(block);
                mapData.push({ x: bx, y: 1, z: bz });
            }
        }

        // --- MANEJO DE MAPAS ---
        function exportMap() {
            const blob = new Blob([JSON.stringify(mapData)], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = "mapa.json"; a.click();
            location.reload();
        }

        function handleMapUpload(e) {
            const reader = new FileReader();
            reader.onload = (ev) => {
                mapData = JSON.parse(ev.target.result);
                document.getElementById('play-btn').disabled = false;
                alert("Mapa cargado. ¡Ya puedes jugar!");
            };
            reader.readAsText(e.target.files[0]);
        }

        // --- MODO JUEGO ---
        function startPlayMode() {
            isPlaying = true;
            isEditor = false;
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('game-ui').style.display = 'block';
            document.getElementById('room-info').style.display = 'block';
            
            initBase();
            
            // Cargar mapa
            mapData.forEach(d => {
                const b = new THREE.Mesh(new THREE.BoxGeometry(2,2,2), new THREE.MeshStandardMaterial({color: 0x2ecc71}));
                b.position.set(d.x, d.y, d.z);
                scene.add(b);
            });

            // Jugador
            player = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshStandardMaterial({color: 0xff0000}));
            player.position.y = 1;
            scene.add(player);

            setupControls();
            animate();
        }

        function setupControls() {
            window.addEventListener('keydown', (e) => {
                if(e.code == 'KeyW') moveForward = true;
                if(e.code == 'KeyS') moveBackward = true;
                if(e.code == 'KeyA') moveLeft = true;
                if(e.code == 'KeyD') moveRight = true;
            });
            window.addEventListener('keyup', (e) => {
                if(e.code == 'KeyW') moveForward = false;
                if(e.code == 'KeyS') moveBackward = false;
                if(e.code == 'KeyA') moveLeft = false;
                if(e.code == 'KeyD') moveRight = false;
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            if (isPlaying && player) {
                const delta = clock.getDelta();
                const speed = 10 * delta;

                if (moveForward) player.translateZ(-speed);
                if (moveBackward) player.translateZ(speed);
                if (moveLeft) player.translateX(-speed);
                if (moveRight) player.translateX(speed);

                // CÁMARA CORREGIDA (Detrás del jugador, no invertida)
                const camOffset = new THREE.Vector3(0, 5, 10); // 10 unidades atrás
                const targetPos = player.position.clone().add(camOffset);
                camera.position.lerp(targetPos, 0.1);
                camera.lookAt(player.position);
            }
            renderer.render(scene, camera);
        }

        function connectToPeer() {
            const targetId = document.getElementById('peer-id-input').value;
            conn = peer.connect(targetId);
            conn.on('open', () => {
                alert("Conectado con éxito");
                startPlayMode();
            });
        }

        window.addEventListener('resize', () => {
            if(camera) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
    </script>
</body>
</html>
