<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Roblox Clone - Editor & Play</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #222; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .panel { pointer-events: auto; background: rgba(0,0,0,0.85); color: white; padding: 20px; border-radius: 10px; border: 2px solid #444; }
        
        #main-menu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 400px; text-align: center; }
        #editor-controls { position: absolute; top: 20px; right: 20px; display: none; }
        #game-ui { position: absolute; bottom: 20px; left: 20px; display: none; }
        #chat-messages { height: 100px; width: 300px; overflow-y: auto; background: rgba(0,0,0,0.5); margin-bottom: 5px; font-size: 13px; }
        
        button { cursor: pointer; padding: 10px 20px; margin: 10px 5px; border: none; border-radius: 5px; font-weight: bold; transition: 0.3s; }
        .btn-green { background: #2ecc71; color: white; }
        .btn-blue { background: #3498db; color: white; }
        .btn-red { background: #e74c3c; color: white; }
        button:disabled { background: #555; cursor: not-allowed; }
        input { padding: 8px; border-radius: 5px; border: 1px solid #444; width: 80%; margin-bottom: 10px; }
        
        #crosshair { position: absolute; top: 50%; left: 50%; width: 10px; height: 10px; background: white; border-radius: 50%; transform: translate(-50%, -50%); display: none; }
    </style>
</head>
<body>

    <div id="crosshair"></div>

    <div id="ui-layer">
        <div id="main-menu" class="panel">
            <h1>MI ROBLOX P2P</h1>
            <p>1. Crea tu mapa en el editor</p>
            <button class="btn-blue" onclick="openEditor()">Ir al Editor de Mapas</button>
            <hr>
            <p>2. Carga un mapa para jugar</p>
            <input type="file" id="map-upload" accept=".json" style="display:none" onchange="handleMapUpload(event)">
            <button class="btn-green" onclick="document.getElementById('map-upload').click()">Importar Mapa para Jugar</button>
            <div id="map-status" style="color: #e74c3c; font-size: 12px;">Estado: Mapa no cargado</div>
            <br>
            <input type="text" id="username" placeholder="Nombre de usuario...">
            <button id="play-btn" class="btn-green" disabled onclick="startPlayMode()">¡EMPEZAR A JUGAR!</button>
        </div>

        <div id="editor-controls" class="panel">
            <h3>Modo Editor</h3>
            <button class="btn-blue" onclick="spawnBlock()">Poner Bloque (Random)</button>
            <button class="btn-green" onclick="exportMap()">Exportar y Guardar Mapa</button>
            <button class="btn-red" onclick="location.reload()">Salir al Menú</button>
        </div>

        <div id="game-ui">
            <div id="chat-messages"></div>
            <input type="text" id="chat-input" placeholder="Escribe y pulsa Enter..." style="pointer-events: auto;">
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let scene, camera, renderer, player, clock;
        let mapData = [];
        let isPlaying = false;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();

        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xa0a0a0);
            scene.fog = new THREE.Fog(0xa0a0a0, 10, 50);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const light = new THREE.HemisphereLight(0xffffff, 0x444444);
            light.position.set(0, 20, 0);
            scene.add(light);

            const grid = new THREE.GridHelper(100, 100, 0x000000, 0x000000);
            grid.material.opacity = 0.2;
            grid.material.transparent = true;
            scene.add(grid);

            clock = new THREE.Clock();
            animate();
        }

        // --- FUNCIONES DEL EDITOR ---
        function openEditor() {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('editor-controls').style.display = 'block';
            initScene();
            camera.position.set(10, 10, 10);
            camera.lookAt(0,0,0);
        }

        function spawnBlock() {
            const size = 2;
            const geo = new THREE.BoxGeometry(size, size, size);
            const mat = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff });
            const mesh = new THREE.Mesh(geo, mat);
            
            const x = Math.floor(Math.random() * 10 - 5) * 2;
            const z = Math.floor(Math.random() * 10 - 5) * 2;
            mesh.position.set(x, size/2, z);
            
            scene.add(mesh);
            mapData.push({ x: x, y: size/2, z: z, color: mat.color.getHex() });
        }

        function exportMap() {
            if(mapData.length === 0) return alert("¡Crea algo primero!");
            const dataStr = JSON.stringify(mapData);
            const blob = new Blob([dataStr], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = "mi_mundo_roblox.json";
            link.click();
            alert("Mapa exportado. Ahora impórtalo en el menú para jugar.");
            location.reload();
        }

        // --- FUNCIONES DE CARGA Y JUEGO ---
        function handleMapUpload(event) {
            const file = event.target.files[0];
            const reader = new FileReader();
            reader.onload = (e) => {
                mapData = JSON.parse(e.target.result);
                document.getElementById('map-status').innerText = "Estado: ¡Mapa Cargado Correctamente!";
                document.getElementById('map-status').style.color = "#2ecc71";
                document.getElementById('play-btn').disabled = false;
            };
            reader.readAsText(file);
        }

        function startPlayMode() {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('game-ui').style.display = 'block';
            document.getElementById('crosshair').style.display = 'block';
            
            initScene();
            
            // Reconstruir mapa cargado
            mapData.forEach(obj => {
                const mesh = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 2, 2),
                    new THREE.MeshStandardMaterial({ color: obj.color })
                );
                mesh.position.set(obj.x, obj.y, obj.z);
                scene.add(mesh);
            });

            // Crear Jugador
            const playerGeo = new THREE.BoxGeometry(1, 2, 1);
            const playerMat = new THREE.MeshStandardMaterial({ color: 0x3498db });
            player = new THREE.Mesh(playerGeo, playerMat);
            player.position.y = 2;
            scene.add(player);

            isPlaying = true;
            setupControls();
            
            // Lock pointer para mover cámara con el mouse
            document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock;
            document.body.requestPointerLock();
        }

        // --- SISTEMA DE MOVIMIENTO ---
        function setupControls() {
            document.addEventListener('keydown', (e) => {
                switch (e.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'Space': if(canJump) velocity.y += 5; canJump = false; break;
                }
            });
            document.addEventListener('keyup', (e) => {
                switch (e.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyD': moveRight = false; break;
                }
            });
            document.addEventListener('mousemove', (e) => {
                if(isPlaying) {
                    player.rotation.y -= e.movementX * 0.002;
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (isPlaying && player) {
                const delta = clock.getDelta();

                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 2.0 * delta; // Gravedad

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 100.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 100.0 * delta;

                player.translateX(-velocity.x * delta);
                player.translateZ(-velocity.z * delta);
                player.position.y += (velocity.y * delta);

                if (player.position.y < 1) {
                    velocity.y = 0;
                    player.position.y = 1;
                    canJump = true;
                }

                // Cámara sigue al jugador
                const relativeCameraOffset = new THREE.Vector3(0, 5, 10);
                const cameraOffset = relativeCameraOffset.applyMatrix4(player.matrixWorld);
                camera.position.x = cameraOffset.x;
                camera.position.y = cameraOffset.y;
                camera.position.z = cameraOffset.z;
                camera.lookAt(player.position);
            }
            
            if(renderer) renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            if(camera) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
    </script>
</body>
</html>
