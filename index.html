<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOOM P2P - Multiplayer Shooter RPG 3ra Persona</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            pointer-events: none;
        }
        #connection-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 10px;
            border: 2px solid #ff0000;
            z-index: 1000;
            text-align: center;
            box-shadow: 0 0 20px rgba(255,0,0,0.5);
        }
        #connection-panel h1 {
            margin-top: 0;
            color: #ff0000;
            text-transform: uppercase;
            letter-spacing: 3px;
        }
        #connection-panel input, #connection-panel button {
            margin: 10px;
            padding: 10px;
            font-size: 16px;
            border-radius: 5px;
        }
        #connection-panel input {
            background: #333;
            color: white;
            border: 1px solid #ff0000;
            width: 250px;
        }
        #connection-panel button {
            background: #ff0000;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        #connection-panel button:hover {
            background: #cc0000;
            transform: scale(1.05);
        }
        #connection-status {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            font-size: 14px;
        }
        #hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #ff0000;
            z-index: 100;
            pointer-events: none;
        }
        .health-bar {
            width: 200px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin: 5px 0;
        }
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6600);
            width: 100%;
            transition: width 0.3s;
        }
        .ammo-count {
            font-size: 24px;
            font-weight: bold;
            color: #ffaa00;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: red;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255,0,0,0.5);
            pointer-events: none;
            z-index: 50;
        }
    </style>
</head>
<body>
    <div id="connection-panel">
        <h1>DOOM P2P MULTIPLAYER</h1>
        <input type="text" id="peer-id" placeholder="Tu ID (opcional)" readonly>
        <br>
        <input type="text" id="connect-peer" placeholder="ID del oponente">
        <br>
        <button onclick="connectToPeer()">CONECTAR</button>
        <button onclick="createGame()">CREAR PARTIDA</button>
        <p style="margin-top: 20px; font-size: 12px; color: #999;">Comparte tu ID con un amigo para jugar</p>
    </div>

    <div id="connection-status">Desconectado</div>
    <div id="info">FPS: <span id="fps">0</span> | Jugadores: <span id="player-count">1</span></div>
    <div id="hud">
        <div>Salud: <span id="health">100</span></div>
        <div class="health-bar">
            <div class="health-fill" id="health-fill" style="width: 100%"></div>
        </div>
        <div>Municiones: <span class="ammo-count" id="ammo">30</span></div>
        <div>Puntuación: <span id="score">0</span></div>
    </div>
    <div id="crosshair">+</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.3.2/dist/peerjs.min.js"></script>

    <script>
        // Configuración del juego
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111122);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Luces
        const ambientLight = new THREE.AmbientLight(0x404060);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Suelo con textura tipo DOOM
        const gridHelper = new THREE.GridHelper(50, 20, 0xff0000, 0x440000);
        scene.add(gridHelper);
        
        const floorGeometry = new THREE.PlaneGeometry(50, 50);
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.7, metalness: 0.1 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -0.01;
        floor.receiveShadow = true;
        scene.add(floor);

        // Elementos decorativos tipo DOOM
        function createPillar(x, z) {
            const geometry = new THREE.BoxGeometry(1, 5, 1);
            const material = new THREE.MeshStandardMaterial({ color: 0x884444 });
            const pillar = new THREE.Mesh(geometry, material);
            pillar.position.set(x, 2.5, z);
            pillar.castShadow = true;
            pillar.receiveShadow = true;
            scene.add(pillar);
            
            const topGeometry = new THREE.BoxGeometry(1.2, 0.5, 1.2);
            const topMaterial = new THREE.MeshStandardMaterial({ color: 0xaa5555 });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.set(x, 5.25, z);
            top.castShadow = true;
            top.receiveShadow = true;
            scene.add(top);
        }

        // Crear columnas al estilo DOOM
        createPillar(-10, -10);
        createPillar(10, -10);
        createPillar(-10, 10);
        createPillar(10, 10);
        createPillar(0, -15);
        createPillar(0, 15);

        // Crear paredes
        function createWall(x, z, width, height, depth, rotationY) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({ color: 0x663333 });
            const wall = new THREE.Mesh(geometry, material);
            wall.position.set(x, height/2, z);
            wall.rotation.y = rotationY;
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);
        }

        createWall(-20, 0, 1, 4, 40, 0);
        createWall(20, 0, 1, 4, 40, 0);
        createWall(0, -20, 40, 4, 1, 0);
        createWall(0, 20, 40, 4, 1, 0);

        // Jugador local
        const player = {
            mesh: null,
            id: 'local',
            health: 100,
            ammo: 30,
            score: 0,
            position: new THREE.Vector3(0, 1, 0),
            rotation: 0,
            velocity: new THREE.Vector3()
        };

        // Enemigos (otros jugadores)
        const enemies = new Map();

        // Crear jugador local
        function createPlayerMesh(color = 0x00ff00, isLocal = true) {
            const group = new THREE.Group();
            
            // Cuerpo
            const bodyGeo = new THREE.BoxGeometry(1, 2, 1);
            const bodyMat = new THREE.MeshStandardMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1;
            body.castShadow = true;
            body.receiveShadow = true;
            group.add(body);
            
            // Cabeza
            const headGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xffaa00 });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 2.4;
            head.castShadow = true;
            head.receiveShadow = true;
            group.add(head);
            
            // Arma (para tercera persona)
            const weaponGeo = new THREE.BoxGeometry(0.3, 0.3, 1.5);
            const weaponMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const weapon = new THREE.Mesh(weaponGeo, weaponMat);
            weapon.position.set(0.5, 1.2, 0.8);
            weapon.rotation.x = Math.PI / 4;
            weapon.castShadow = true;
            group.add(weapon);
            
            if (!isLocal) {
                // Indicador de enemigo
                const markerGeo = new THREE.ConeGeometry(0.5, 0.5, 8);
                const markerMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
                const marker = new THREE.Mesh(markerGeo, markerMat);
                marker.position.y = 3;
                group.add(marker);
            }
            
            return group;
        }

        player.mesh = createPlayerMesh(0x00ff00, true);
        player.mesh.position.copy(player.position);
        scene.add(player.mesh);

        // Controles
        const keys = {};
        const moveSpeed = 0.1;
        const rotateSpeed = 0.03;

        window.addEventListener('keydown', (e) => keys[e.code] = true);
        window.addEventListener('keyup', (e) => keys[e.code] = false);

        // Configuración PeerJS
        let peer;
        let conn;
        const localId = Math.random().toString(36).substr(2, 8);
        
        document.getElementById('peer-id').value = localId;

        function createGame() {
            document.getElementById('connection-panel').style.display = 'none';
            peer = new Peer(localId);
            
            peer.on('open', (id) => {
                console.log('Mi ID:', id);
                updateConnectionStatus('Esperando oponente...', '#ffaa00');
            });
            
            peer.on('connection', (connection) => {
                conn = connection;
                setupConnection(conn);
            });
        }

        function connectToPeer() {
            const remoteId = document.getElementById('connect-peer').value;
            if (!remoteId) return;
            
            document.getElementById('connection-panel').style.display = 'none';
            peer = new Peer();
            
            peer.on('open', () => {
                conn = peer.connect(remoteId);
                setupConnection(conn);
            });
        }

        function setupConnection(connection) {
            conn = connection;
            
            conn.on('open', () => {
                console.log('Conectado a:', conn.peer);
                updateConnectionStatus('Conectado', '#00ff00');
                
                // Enviar datos iniciales
                sendPlayerData();
                
                // Enviar datos periódicamente
                setInterval(sendPlayerData, 50);
            });
            
            conn.on('data', (data) => {
                handleEnemyData(data);
            });
            
            conn.on('close', () => {
                updateConnectionStatus('Desconectado', '#ff0000');
            });
        }

        function updateConnectionStatus(text, color) {
            const status = document.getElementById('connection-status');
            status.textContent = text;
            status.style.backgroundColor = color;
        }

        function sendPlayerData() {
            if (conn && conn.open) {
                conn.send({
                    id: localId,
                    position: player.position,
                    rotation: player.rotation,
                    health: player.health,
                    ammo: player.ammo,
                    score: player.score
                });
            }
        }

        function handleEnemyData(data) {
            if (!enemies.has(data.id)) {
                // Crear nuevo enemigo
                const enemyMesh = createPlayerMesh(0xff0000, false);
                scene.add(enemyMesh);
                enemies.set(data.id, {
                    mesh: enemyMesh,
                    health: data.health,
                    lastUpdate: Date.now()
                });
            }
            
            const enemy = enemies.get(data.id);
            if (enemy) {
                enemy.mesh.position.copy(data.position);
                enemy.mesh.rotation.y = data.rotation;
                enemy.health = data.health;
                enemy.lastUpdate = Date.now();
                
                // Actualizar HUD con información del enemigo
                document.getElementById('player-count').textContent = enemies.size + 1;
            }
        }

        // Sistema de disparo
        window.addEventListener('click', () => {
            if (player.ammo <= 0) return;
            
            player.ammo--;
            document.getElementById('ammo').textContent = player.ammo;
            
            // Crear proyectil
            const bulletGeo = new THREE.SphereGeometry(0.2);
            const bulletMat = new THREE.MeshStandardMaterial({ color: 0xffaa00 });
            const bullet = new THREE.Mesh(bulletGeo, bulletMat);
            
            // Posición inicial (desde el arma)
            bullet.position.copy(player.position);
            bullet.position.y += 1.5;
            
            // Dirección (hacia adelante del jugador)
            const direction = new THREE.Vector3(
                Math.sin(player.rotation),
                0,
                Math.cos(player.rotation)
            );
            
            scene.add(bullet);
            
            // Animar proyectil
            let distance = 0;
            const maxDistance = 20;
            const bulletSpeed = 0.5;
            
            function animateBullet() {
                if (distance < maxDistance) {
                    bullet.position.addScaledVector(direction, bulletSpeed);
                    distance += bulletSpeed;
                    
                    // Verificar colisiones con enemigos
                    enemies.forEach((enemy, id) => {
                        if (bullet.position.distanceTo(enemy.mesh.position) < 1.5) {
                            scene.remove(bullet);
                            // Daño al enemigo
                            if (conn && conn.open) {
                                conn.send({
                                    type: 'damage',
                                    target: id,
                                    damage: 10
                                });
                            }
                            return;
                        }
                    });
                    
                    requestAnimationFrame(animateBullet);
                } else {
                    scene.remove(bullet);
                }
            }
            
            animateBullet();
        });

        // Recargar
        window.addEventListener('keydown', (e) => {
            if (e.code === 'KeyR') {
                player.ammo = 30;
                document.getElementById('ammo').textContent = player.ammo;
            }
        });

        // Animación y lógica del juego
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 0;

        function animate() {
            requestAnimationFrame(animate);

            // Calcular FPS
            frameCount++;
            const now = performance.now();
            const delta = now - lastTime;
            
            if (delta >= 1000) {
                fps = frameCount;
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastTime = now;
            }

            // Movimiento del jugador (estilo DOOM)
            if (keys['KeyW'] || keys['ArrowUp']) {
                player.position.x += Math.sin(player.rotation) * moveSpeed;
                player.position.z += Math.cos(player.rotation) * moveSpeed;
            }
            if (keys['KeyS'] || keys['ArrowDown']) {
                player.position.x -= Math.sin(player.rotation) * moveSpeed;
                player.position.z -= Math.cos(player.rotation) * moveSpeed;
            }
            if (keys['KeyA'] || keys['ArrowLeft']) {
                player.rotation += rotateSpeed;
            }
            if (keys['KeyD'] || keys['ArrowRight']) {
                player.rotation -= rotateSpeed;
            }
            
            // Limitar movimiento dentro del mapa
            player.position.x = Math.max(-18, Math.min(18, player.position.x));
            player.position.z = Math.max(-18, Math.min(18, player.position.z));
            
            // Actualizar malla del jugador
            player.mesh.position.copy(player.position);
            player.mesh.rotation.y = player.rotation;
            
            // Cámara en tercera persona
            const camOffset = new THREE.Vector3(
                Math.sin(player.rotation) * 8,
                5,
                Math.cos(player.rotation) * 8
            );
            camera.position.copy(player.position.clone().add(camOffset));
            camera.lookAt(player.position.clone().add(new THREE.Vector3(0, 2, 0)));

            // Actualizar HUD
            document.getElementById('health').textContent = player.health;
            document.getElementById('health-fill').style.width = player.health + '%';
            document.getElementById('score').textContent = player.score;

            // Limpiar enemigos desconectados
            const now_time = Date.now();
            enemies.forEach((enemy, id) => {
                if (now_time - enemy.lastUpdate > 1000) {
                    scene.remove(enemy.mesh);
                    enemies.delete(id);
                }
            });

            renderer.render(scene, camera);
        }

        animate();

        // Ajustar tamaño de ventana
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Sistema de daño simple
        setInterval(() => {
            // Detectar colisiones con enemigos
            enemies.forEach((enemy) => {
                if (player.position.distanceTo(enemy.mesh.position) < 2) {
                    player.health = Math.max(0, player.health - 1);
                }
            });
            
            // Regeneración si está muy bajo
            if (player.health < 20) {
                player.health = Math.min(100, player.health + 0.1);
            }
        }, 100);
    </script>
</body>
</html>
