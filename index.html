<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Mini RTS ¬∑ Age of Grid</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: #1a2a1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #gameContainer {
            background: #2a3a2a;
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.7);
        }
        canvas {
            display: block;
            margin: 0 auto;
            border: 3px solid #6b4e3a;
            border-radius: 8px;
            cursor: crosshair;
        }
        #infoPanel {
            margin-top: 12px;
            color: #e0d8b0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #3b4a3b;
            padding: 8px 16px;
            border-radius: 40px;
            border: 1px solid #8b7a5a;
        }
        #resources {
            font-size: 1.3rem;
            font-weight: bold;
            text-shadow: 2px 2px 0 #2a3a2a;
        }
        #selectedInfo {
            background: #4a5a4a;
            padding: 4px 16px;
            border-radius: 30px;
            border: 1px solid #b0a880;
        }
        button {
            background: #6b8c5c;
            border: none;
            color: white;
            font-weight: bold;
            padding: 6px 15px;
            border-radius: 30px;
            cursor: pointer;
            border-bottom: 3px solid #3a5a3a;
            transition: 0.1s ease;
            font-size: 1rem;
        }
        button:hover {
            background: #7b9c6c;
            border-bottom-width: 1px;
            transform: translateY(2px);
        }
        button:active {
            transform: translateY(4px);
            border-bottom-width: 0;
        }
    </style>
</head>
<body>
<div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="infoPanel">
        <div id="resources">üå≤ 0  üçñ 0</div>
        <div id="selectedInfo">üë§ Ninguna unidad</div>
        <button id="buildBtn">üè† Construir (50üå≤)</button>
    </div>
</div>

<script>
    // --------------------------------------------------------------
    // CONSTANTES Y CONFIGURACI√ìN
    // --------------------------------------------------------------
    const CELDA = 40;                // p√≠xeles por celda
    const COLUMNAS = 20;             // 800/40
    const FILAS = 15;                // 600/40

    // Tipos de terreno
    const TERRENO = {
        TIERRA: 0,
        AGUA: 1,
        BOSQUE: 2,
        MONTA√ëA: 3
    };

    // Colores para visualizaci√≥n
    const COLOR_TERRENO = [
        "#6b8e4c", // tierra
        "#3a6ea5", // agua
        "#2d5a2d", // bosque (√°rboles)
        "#7a6a5a"  // monta√±a
    ];

    // --------------------------------------------------------------
    // RECURSOS DEL JUGADOR
    // --------------------------------------------------------------
    let recursos = { madera: 100, comida: 50 };

    // --------------------------------------------------------------
    // MAPA (matriz de celdas)
    // --------------------------------------------------------------
    let mapa = [];
    for (let f = 0; f < FILAS; f++) {
        let fila = [];
        for (let c = 0; c < COLUMNAS; c++) {
            // Generar terreno aleatorio ponderado
            let r = Math.random();
            let tipo;
            if (r < 0.6) tipo = TERRENO.TIERRA;
            else if (r < 0.75) tipo = TERRENO.BOSQUE;
            else if (r < 0.9) tipo = TERRENO.AGUA;
            else tipo = TERRENO.MONTA√ëA;

            fila.push({
                tipo: tipo,
                recurso: (tipo === TERRENO.BOSQUE) ? { tipo: "madera", cantidad: 100 } : null,
                edificio: null,
                unidad: null
            });
        }
        mapa.push(fila);
    }

    // Asegurar que la posici√≥n inicial del jugador sea tierra
    mapa[7][5].tipo = TERRENO.TIERRA;
    mapa[7][5].recurso = null;

    // --------------------------------------------------------------
    // CLASES ENTIDADES
    // --------------------------------------------------------------
    class Unidad {
        constructor(x, y, tipo, hp, ataque, velocidad) {
            this.x = x;             // celda columna
            this.y = y;             // celda fila
            this.tipo = tipo;       // "aldeano" o "soldado"
            this.hp = hp;
            this.ataque = ataque;
            this.velocidad = velocidad; // celdas por segundo (aprox)
            this.destino = null;     // {x, y}
            this.camino = [];         // puntos intermedios
            this.recursoCargando = null; // para aldeano: "madera" o null
            this.carga = 0;           // cantidad que lleva
            this.capacidadCarga = 10;  // m√°xima carga
            this.estado = "idle";      // idle, moviendo, recolectando, construyendo
            this.objetivoRecurso = null; // celda del √°rbol
        }

        // Asignar nuevo destino (clic derecho)
        irA(destX, destY) {
            if (destX < 0 || destX >= COLUMNAS || destY < 0 || destY >= FILAS) return false;
            // Por simplicidad, movimiento directo (sin pathfinding complejo)
            this.destino = { x: destX, y: destY };
            this.camino = []; // reset camino (podr√≠amos implementar A* despu√©s)
            this.estado = "moviendo";
            return true;
        }

        // Actualizar movimiento (llamado por frame)
        actualizarMovimiento(dt) {
            if (this.estado !== "moviendo" || !this.destino) return;

            let dx = this.destino.x - this.x;
            let dy = this.destino.y - this.y;
            let distancia = Math.sqrt(dx*dx + dy*dy);

            if (distancia < 0.1) {
                // Lleg√≥
                this.x = this.destino.x;
                this.y = this.destino.y;
                this.destino = null;
                this.estado = "idle";
                // Si estaba yendo a recolectar, empezar recolecci√≥n
                if (this.objetivoRecurso) {
                    this.recolectar(this.objetivoRecurso);
                }
                return;
            }

            // Movimiento proporcional a velocidad (dt en segundos, asumimos 60fps => dt‚âà0.016)
            // Normalizamos y multiplicamos por velocidad * dt (convertimos a celdas/frame)
            let step = this.velocidad * dt; // celdas a mover este frame
            if (step > distancia) step = distancia;

            this.x += (dx / distancia) * step;
            this.y += (dy / distancia) * step;
        }

        // Recolectar un recurso (arbol) cercano
        recolectar(recursoCelda) {
            if (this.tipo !== "aldeano") return;
            // Verificar adyacencia (8 direcciones)
            let adyacente = false;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    let nx = recursoCelda.x + dx;
                    let ny = recursoCelda.y + dy;
                    if (nx === Math.round(this.x) && ny === Math.round(this.y)) {
                        adyacente = true;
                        break;
                    }
                }
            }
            if (!adyacente) {
                // Si no est√° adyacente, moverse hacia √©l
                this.irA(recursoCelda.x, recursoCelda.y);
                this.objetivoRecurso = recursoCelda;
                return;
            }

            // Adyacente: empezar recolecci√≥n
            this.estado = "recolectando";
            this.objetivoRecurso = recursoCelda;
        }

        // Llamado cada frame para proceso de recolecci√≥n
        actualizarRecoleccion(dt) {
            if (this.estado !== "recolectando" || !this.objetivoRecurso) return;

            let celda = mapa[this.objetivoRecurso.y][this.objetivoRecurso.x];
            if (!celda.recurso || celda.recurso.cantidad <= 0) {
                this.estado = "idle";
                this.objetivoRecurso = null;
                return;
            }

            // Recolectar cada 0.5 segundos (simulamos con acumulador)
            if (!this.recoleccionTimer) this.recoleccionTimer = 0;
            this.recoleccionTimer += dt;
            while (this.recoleccionTimer >= 0.5 && celda.recurso.cantidad > 0 && this.carga < this.capacidadCarga) {
                this.recoleccionTimer -= 0.5;
                let recolectado = Math.min(10, celda.recurso.cantidad, this.capacidadCarga - this.carga);
                celda.recurso.cantidad -= recolectado;
                this.carga += recolectado;
                recursos.madera += recolectado; // directamente al jugador (simplificado)
            }

            if (celda.recurso.cantidad <= 0) {
                celda.recurso = null;
                this.estado = "idle";
                this.objetivoRecurso = null;
            }

            if (this.carga >= this.capacidadCarga) {
                // Llevar al centro urbano (hardcodeado en 5,7)
                this.irA(5, 7); // centro urbano
                this.estado = "moviendo";
                // Al llegar depositar√° (lo har√≠amos en llegada)
            }
        }
    }

    // --------------------------------------------------------------
    // UNIDADES DEL JUGADOR
    // --------------------------------------------------------------
    let unidades = [];

    // Crear aldeano inicial en (5,7) - centro urbano
    unidades.push(new Unidad(5, 7, "aldeano", 25, 3, 4.0));

    // --------------------------------------------------------------
    // SELECCI√ìN
    // --------------------------------------------------------------
    let unidadSeleccionada = null;

    // --------------------------------------------------------------
    // CANVAS Y CONTEXTO
    // --------------------------------------------------------------
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // --------------------------------------------------------------
    // INTERFAZ
    // --------------------------------------------------------------
    const resourcesSpan = document.getElementById('resources');
    const selectedInfoSpan = document.getElementById('selectedInfo');
    const buildBtn = document.getElementById('buildBtn');

    function actualizarUI() {
        resourcesSpan.innerHTML = `üå≤ ${recursos.madera}  üçñ ${recursos.comida}`;
        if (unidadSeleccionada) {
            selectedInfoSpan.innerHTML = `üë§ ${unidadSeleccionada.tipo} (${Math.round(unidadSeleccionada.x)},${Math.round(unidadSeleccionada.y)}) ${unidadSeleccionada.estado}`;
        } else {
            selectedInfoSpan.innerHTML = `üë§ Ninguna unidad`;
        }
    }

    // --------------------------------------------------------------
    // DIBUJADO
    // --------------------------------------------------------------
    function dibujarMapa() {
        for (let fila = 0; fila < FILAS; fila++) {
            for (let col = 0; col < COLUMNAS; col++) {
                let celda = mapa[fila][col];
                // Color base por terreno
                ctx.fillStyle = COLOR_TERRENO[celda.tipo];
                ctx.fillRect(col * CELDA, fila * CELDA, CELDA-1, CELDA-1);

                // Dibujar recursos (√°rboles)
                if (celda.recurso) {
                    if (celda.recurso.tipo === "madera") {
                        ctx.fillStyle = "#3c8c3c";
                        ctx.beginPath();
                        ctx.arc(col * CELDA + CELDA/2, fila * CELDA + CELDA/2, 12, 0, 2*Math.PI);
                        ctx.fill();
                        ctx.fillStyle = "#5a3e1a";
                        ctx.fillRect(col * CELDA + 15, fila * CELDA + 25, 10, 10);
                    }
                }

                // Dibujar edificio si hay (solo centro por ahora)
                if (celda.edificio) {
                    ctx.fillStyle = "#a52a2a";
                    ctx.fillRect(col * CELDA + 4, fila * CELDA + 4, CELDA-8, CELDA-8);
                }

                // Dibujar unidad si hay
                if (celda.unidad) {
                    // No dibujamos aqu√≠ porque las unidades tienen posici√≥n float
                }
            }
        }

        // Dibujar unidades (para que est√©n sobre el mapa)
        unidades.forEach(u => {
            let x = u.x * CELDA;
            let y = u.y * CELDA;
            ctx.fillStyle = (u.tipo === "aldeano") ? "#f0d880" : "#c04040";
            ctx.beginPath();
            ctx.arc(x + CELDA/2, y + CELDA/2, 12, 0, 2*Math.PI);
            ctx.fill();
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 2;
            ctx.stroke();
            // Indicador de selecci√≥n
            if (unidadSeleccionada === u) {
                ctx.strokeStyle = "#ffd700";
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x + CELDA/2, y + CELDA/2, 16, 0, 2*Math.PI);
                ctx.stroke();
            }
            // Barra de carga si lleva recursos
            if (u.carga > 0) {
                ctx.fillStyle = "#8b4513";
                ctx.fillRect(x + 5, y - 8, 30 * (u.carga / u.capacidadCarga), 4);
            }
        });

        // Dibujar rejilla
        ctx.strokeStyle = "#4a6a4a";
        ctx.lineWidth = 1;
        for (let i = 0; i <= COLUMNAS; i++) {
            ctx.beginPath();
            ctx.moveTo(i * CELDA, 0);
            ctx.lineTo(i * CELDA, canvas.height);
            ctx.strokeStyle = "#6a8a6a";
            ctx.stroke();
        }
        for (let i = 0; i <= FILAS; i++) {
            ctx.beginPath();
            ctx.moveTo(0, i * CELDA);
            ctx.lineTo(canvas.width, i * CELDA);
            ctx.stroke();
        }
    }

    // --------------------------------------------------------------
    // ACTUALIZACI√ìN POR FRAME (loop)
    // --------------------------------------------------------------
    let ultimoTiempo = performance.now() / 1000;

    function gameLoop(now) {
        now /= 1000; // convertir a segundos
        let dt = Math.min(0.1, now - ultimoTiempo); // limitar dt m√°ximo
        ultimoTiempo = now;

        // Actualizar unidades
        unidades.forEach(u => {
            u.actualizarMovimiento(dt);
            u.actualizarRecoleccion(dt);

            // Actualizar ocupaci√≥n en mapa (solo para referencia visual)
            // Limpiar asignaciones previas
            for (let f = 0; f < FILAS; f++) {
                for (let c = 0; c < COLUMNAS; c++) {
                    if (mapa[f][c].unidad === u) mapa[f][c].unidad = null;
                }
            }
            // Asignar a la celda redondeada
            let cx = Math.round(u.x);
            let cy = Math.round(u.y);
            if (cx >= 0 && cx < COLUMNAS && cy >= 0 && cy < FILAS) {
                mapa[cy][cx].unidad = u;
            }
        });

        dibujarMapa();
        actualizarUI();

        requestAnimationFrame(gameLoop);
    }

    // --------------------------------------------------------------
    // EVENTOS DE RAT√ìN
    // --------------------------------------------------------------
    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        const mouseX = (e.clientX - rect.left) * scaleX;
        const mouseY = (e.clientY - rect.top) * scaleY;

        const col = Math.floor(mouseX / CELDA);
        const fila = Math.floor(mouseY / CELDA);

        if (e.button === 0) { // Izquierdo: seleccionar
            // Buscar unidad en esa celda (redondeo)
            let unidadEnCelda = unidades.find(u => Math.round(u.x) === col && Math.round(u.y) === fila);
            if (unidadEnCelda) {
                unidadSeleccionada = unidadEnCelda;
            } else {
                // Si no hay unidad, desseleccionar
                unidadSeleccionada = null;
            }
        } else if (e.button === 2) { // Derecho: ordenar movimiento
            e.preventDefault();
            if (unidadSeleccionada) {
                unidadSeleccionada.irA(col, fila);
                // Si es aldeano y hay un recurso, asignar recolecci√≥n al llegar (por simplicidad, comprobamos si hay recurso)
                if (unidadSeleccionada.tipo === "aldeano" && mapa[fila][col].recurso) {
                    unidadSeleccionada.objetivoRecurso = { x: col, y: fila };
                }
            }
        }
    });

    // Prevenir men√∫ contextual en el canvas
    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    // Bot√≥n construir (simple: gasta madera, crea un edificio si hay selecci√≥n)
    buildBtn.addEventListener('click', () => {
        if (recursos.madera >= 50 && unidadSeleccionada) {
            // Colocar edificio en la celda de la unidad seleccionada (simplificado)
            let x = Math.round(unidadSeleccionada.x);
            let y = Math.round(unidadSeleccionada.y);
            if (mapa[y][x].tipo === TERRENO.TIERRA && !mapa[y][x].edificio) {
                mapa[y][x].edificio = { tipo: "casa", hp: 100 };
                recursos.madera -= 50;
            }
        }
    });

    // --------------------------------------------------------------
    // INICIO
    // --------------------------------------------------------------
    requestAnimationFrame(gameLoop);
</script>
</body>
</html>
