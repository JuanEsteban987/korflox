<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOOM P2P CLASSIC - Multiplayer 2.5D</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            background: #000;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ff0000;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ff0000;
            z-index: 100;
            text-shadow: 0 0 5px #ff0000;
            font-weight: bold;
        }
        #connection-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000;
            color: #ff0000;
            padding: 30px;
            border-radius: 0;
            border: 3px solid #ff0000;
            z-index: 1000;
            text-align: center;
            box-shadow: 0 0 30px #ff0000;
            font-family: 'Courier New', monospace;
        }
        #connection-panel h1 {
            margin-top: 0;
            color: #ff0000;
            text-transform: uppercase;
            letter-spacing: 4px;
            font-size: 32px;
            text-shadow: 0 0 10px #ff0000;
        }
        #connection-panel input, #connection-panel button {
            margin: 10px;
            padding: 12px;
            font-size: 16px;
            border-radius: 0;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        #connection-panel input {
            background: #111;
            color: #ff0000;
            border: 2px solid #ff0000;
            width: 250px;
        }
        #connection-panel button {
            background: #000;
            color: #ff0000;
            border: 2px solid #ff0000;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        #connection-panel button:hover {
            background: #ff0000;
            color: #000;
            transform: scale(1.05);
        }
        #connection-status {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #ff0000;
            background: #000;
            padding: 10px;
            border: 2px solid #ff0000;
            z-index: 100;
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
        }
        #hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #ff0000;
            background: #000;
            padding: 15px;
            border: 2px solid #ff0000;
            z-index: 100;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-shadow: 0 0 5px #ff0000;
        }
        .health-bar {
            width: 200px;
            height: 20px;
            background: #111;
            border: 2px solid #ff0000;
            margin: 5px 0;
        }
        .health-fill {
            height: 100%;
            background: #ff0000;
            width: 100%;
            transition: width 0.1s;
        }
        .ammo-count {
            font-size: 24px;
            font-weight: bold;
            color: #ffaa00;
            text-shadow: 0 0 10px #ffaa00;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0000;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 0 0 15px #ff0000;
            pointer-events: none;
            z-index: 50;
        }
        #minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: #000;
            border: 3px solid #ff0000;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="connection-panel">
        <h1>ðŸ”´ DOOM P2P CLASSIC</h1>
        <input type="text" id="peer-id" placeholder="Tu ID" readonly>
        <br>
        <input type="text" id="connect-peer" placeholder="ID del oponente">
        <br>
        <button onclick="createGame()">CREAR PARTIDA</button>
        <button onclick="connectToPeer()">CONECTAR</button>
        <p style="margin-top: 20px; color: #ff4444;">âš¡ COMPARTE TU ID PARA JUGAR âš¡</p>
    </div>

    <div id="connection-status">ðŸ”´ DESCONECTADO</div>
    <div id="info">FPS: <span id="fps">0</span> | KILLS: <span id="kills">0</span> | JUGADORES: <span id="player-count">1</span></div>
    <div id="hud">
        <div>ðŸ’€ SALUD ðŸ’€</div>
        <div class="health-bar">
            <div class="health-fill" id="health-fill" style="width: 100%"></div>
        </div>
        <div style="margin-top: 10px;">ðŸ”« MUNICIÃ“N: <span class="ammo-count" id="ammo">30</span></div>
        <div style="margin-top: 5px;">ðŸŽ¯ PUNTOS: <span id="score">0</span></div>
    </div>
    <div id="crosshair">âš¡</div>
    <canvas id="minimap" width="200" height="200"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.3.2/dist/peerjs.min.js"></script>

    <script>
        // ConfiguraciÃ³n del juego
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 20); // Vista superior estilo DOOM clÃ¡sico
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = false; // Desactivamos sombras para mejor rendimiento
        document.body.appendChild(renderer.domElement);

        // IluminaciÃ³n tenebrosa tipo DOOM
        const ambientLight = new THREE.AmbientLight(0x402020);
        scene.add(ambientLight);
        
        const pointLight1 = new THREE.PointLight(0xff4422, 0.8, 30);
        pointLight1.position.set(0, 5, 0);
        scene.add(pointLight1);
        
        const pointLight2 = new THREE.PointLight(0x2244ff, 0.5, 30);
        pointLight2.position.set(10, 5, 10);
        scene.add(pointLight2);

        // Suelo con patrÃ³n de DOOM
        const floorGeometry = new THREE.PlaneGeometry(40, 40);
        const textureCanvas = document.createElement('canvas');
        textureCanvas.width = 64;
        textureCanvas.height = 64;
        const ctx = textureCanvas.getContext('2d');
        ctx.fillStyle = '#330000';
        ctx.fillRect(0, 0, 64, 64);
        ctx.strokeStyle = '#660000';
        ctx.lineWidth = 4;
        ctx.strokeRect(0, 0, 64, 64);
        ctx.strokeRect(16, 16, 32, 32);
        
        const texture = new THREE.CanvasTexture(textureCanvas);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(10, 10);
        
        const floorMaterial = new THREE.MeshStandardMaterial({ map: texture, emissive: 0x110000 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -0.1;
        floor.receiveShadow = false;
        scene.add(floor);

        // Paredes estilo DOOM
        function createWall(x, z, width, height, depth, rotationY) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            
            // Textura de pared
            const wallCanvas = document.createElement('canvas');
            wallCanvas.width = 32;
            wallCanvas.height = 32;
            const wallCtx = wallCanvas.getContext('2d');
            wallCtx.fillStyle = '#442222';
            wallCtx.fillRect(0, 0, 32, 32);
            wallCtx.strokeStyle = '#882222';
            wallCtx.lineWidth = 4;
            wallCtx.strokeRect(4, 4, 24, 24);
            
            const wallTexture = new THREE.CanvasTexture(wallCanvas);
            const material = new THREE.MeshStandardMaterial({ map: wallTexture, emissive: 0x221111 });
            
            const wall = new THREE.Mesh(geometry, material);
            wall.position.set(x, height/2, z);
            wall.rotation.y = rotationY;
            scene.add(wall);
        }

        // Crear laberinto estilo DOOM
        createWall(-15, -15, 2, 4, 30, 0);
        createWall(15, -15, 2, 4, 30, 0);
        createWall(-15, 15, 30, 4, 2, 0);
        createWall(15, 15, 30, 4, 2, 0);
        
        // ObstÃ¡culos
        createWall(-5, -5, 4, 4, 4, 0);
        createWall(5, 5, 4, 4, 4, 0);
        createWall(-5, 5, 4, 4, 4, 0);
        createWall(5, -5, 4, 4, 4, 0);

        // Sprite 2D para jugadores
        function createPlayerSprite(color, isLocal = false) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // Dibujar sprite estilo DOOM
            ctx.clearRect(0, 0, 64, 64);
            
            // Cuerpo principal
            ctx.fillStyle = color;
            ctx.fillRect(20, 20, 24, 32);
            
            // Cabeza
            ctx.fillStyle = isLocal ? '#00ff00' : '#ff0000';
            ctx.fillRect(24, 12, 16, 16);
            
            // Arma
            ctx.fillStyle = '#888888';
            ctx.fillRect(44, 28, 16, 8);
            
            // Ojos
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(28, 18, 4, 4);
            ctx.fillRect(36, 18, 4, 4);
            
            if (!isLocal) {
                // Indicador enemigo
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(32, 8, 6, 0, Math.PI * 2);
                ctx.fill();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(2, 2, 1);
            
            return sprite;
        }

        // Jugador local
        const player = {
            sprite: createPlayerSprite('#00ff00', true),
            id: 'local',
            health: 100,
            ammo: 30,
            score: 0,
            kills: 0,
            position: new THREE.Vector3(0, 0, 0),
            rotation: 0
        };
        
        player.sprite.position.copy(player.position);
        player.sprite.position.y = 1;
        scene.add(player.sprite);

        // Enemigos (otros jugadores) como sprites 2D
        const enemies = new Map();

        // Controles
        const keys = {};
        const moveSpeed = 0.15;
        const rotateSpeed = 0.05;

        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'Space') {
                e.preventDefault();
                shoot();
            }
        });
        
        window.addEventListener('keyup', (e) => keys[e.code] = false);

        // ConfiguraciÃ³n PeerJS
        let peer;
        let conn;
        const localId = Math.random().toString(36).substr(2, 8).toUpperCase();
        
        document.getElementById('peer-id').value = localId;

        function createGame() {
            document.getElementById('connection-panel').style.display = 'none';
            peer = new Peer(localId);
            
            peer.on('open', (id) => {
                console.log('Mi ID:', id);
                updateConnectionStatus('ðŸŸ¡ ESPERANDO...', '#ffaa00');
            });
            
            peer.on('connection', (connection) => {
                conn = connection;
                setupConnection(conn);
            });
        }

        function connectToPeer() {
            const remoteId = document.getElementById('connect-peer').value;
            if (!remoteId) return;
            
            document.getElementById('connection-panel').style.display = 'none';
            peer = new Peer();
            
            peer.on('open', () => {
                conn = peer.connect(remoteId);
                setupConnection(conn);
            });
        }

        function setupConnection(connection) {
            conn = connection;
            
            conn.on('open', () => {
                console.log('Conectado a:', conn.peer);
                updateConnectionStatus('ðŸŸ¢ CONECTADO', '#00ff00');
                
                setInterval(sendPlayerData, 50);
            });
            
            conn.on('data', (data) => {
                handleEnemyData(data);
            });
            
            conn.on('close', () => {
                updateConnectionStatus('ðŸ”´ DESCONECTADO', '#ff0000');
            });
        }

        function updateConnectionStatus(text, color) {
            const status = document.getElementById('connection-status');
            status.textContent = text;
            status.style.borderColor = color;
            status.style.color = color;
        }

        function sendPlayerData() {
            if (conn && conn.open) {
                conn.send({
                    id: localId,
                    x: player.position.x,
                    z: player.position.z,
                    rotation: player.rotation,
                    health: player.health,
                    ammo: player.ammo,
                    kills: player.kills
                });
            }
        }

        function handleEnemyData(data) {
            if (!enemies.has(data.id)) {
                // Crear nuevo enemigo como sprite 2D
                const enemySprite = createPlayerSprite('#ff0000', false);
                scene.add(enemySprite);
                enemies.set(data.id, {
                    sprite: enemySprite,
                    health: data.health,
                    lastUpdate: Date.now()
                });
            }
            
            const enemy = enemies.get(data.id);
            if (enemy) {
                enemy.sprite.position.set(data.x, 1, data.z);
                enemy.sprite.material.rotation = data.rotation;
                enemy.health = data.health;
                enemy.lastUpdate = Date.now();
                
                document.getElementById('player-count').textContent = enemies.size + 1;
            }
        }

        // Sistema de disparo
        function shoot() {
            if (player.ammo <= 0) return;
            
            player.ammo--;
            document.getElementById('ammo').textContent = player.ammo;
            
            // Crear proyectil
            const bulletGeo = new THREE.SphereGeometry(0.3);
            const bulletMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0xff4400 });
            const bullet = new THREE.Mesh(bulletGeo, bulletMat);
            
            bullet.position.copy(player.position);
            bullet.position.y = 1;
            
            // DirecciÃ³n (usando la rotaciÃ³n del sprite)
            const direction = new THREE.Vector3(
                Math.sin(player.rotation),
                0,
                Math.cos(player.rotation)
            );
            
            scene.add(bullet);
            
            // Animar proyectil
            let distance = 0;
            const maxDistance = 15;
            const bulletSpeed = 0.4;
            
            function animateBullet() {
                if (distance < maxDistance) {
                    bullet.position.addScaledVector(direction, bulletSpeed);
                    distance += bulletSpeed;
                    
                    // Colisiones con enemigos
                    enemies.forEach((enemy, id) => {
                        if (bullet.position.distanceTo(enemy.sprite.position) < 1.5) {
                            scene.remove(bullet);
                            
                            // Efecto de impacto
                            const impactGeo = new THREE.SphereGeometry(0.5);
                            const impactMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000 });
                            const impact = new THREE.Mesh(impactGeo, impactMat);
                            impact.position.copy(bullet.position);
                            scene.add(impact);
                            
                            setTimeout(() => scene.remove(impact), 100);
                            
                            // DaÃ±o al enemigo
                            if (conn && conn.open) {
                                conn.send({
                                    type: 'damage',
                                    target: id,
                                    damage: 25
                                });
                                
                                // Si mata al enemigo
                                if (enemy.health <= 25) {
                                    player.kills++;
                                    player.score += 100;
                                    document.getElementById('kills').textContent = player.kills;
                                    document.getElementById('score').textContent = player.score;
                                }
                            }
                            
                            return;
                        }
                    });
                    
                    requestAnimationFrame(animateBullet);
                } else {
                    scene.remove(bullet);
                }
            }
            
            animateBullet();
        }

        // Recargar
        window.addEventListener('keydown', (e) => {
            if (e.code === 'KeyR') {
                player.ammo = 30;
                document.getElementById('ammo').textContent = player.ammo;
            }
        });

        // AnimaciÃ³n y lÃ³gica
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 0;

        function animate() {
            requestAnimationFrame(animate);

            // Calcular FPS
            frameCount++;
            const now = performance.now();
            const delta = now - lastTime;
            
            if (delta >= 1000) {
                fps = frameCount;
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastTime = now;
            }

            // Movimiento (invertido para corregir la cÃ¡mara)
            if (keys['KeyW'] || keys['ArrowUp']) {
                player.position.x += Math.sin(player.rotation) * moveSpeed;
                player.position.z += Math.cos(player.rotation) * moveSpeed;
            }
            if (keys['KeyS'] || keys['ArrowDown']) {
                player.position.x -= Math.sin(player.rotation) * moveSpeed;
                player.position.z -= Math.cos(player.rotation) * moveSpeed;
            }
            if (keys['KeyA'] || keys['ArrowLeft']) {
                player.rotation += rotateSpeed;
            }
            if (keys['KeyD'] || keys['ArrowRight']) {
                player.rotation -= rotateSpeed;
            }
            
            // Limitar movimiento
            player.position.x = Math.max(-14, Math.min(14, player.position.x));
            player.position.z = Math.max(-14, Math.min(14, player.position.z));
            
            // Actualizar sprite
            player.sprite.position.copy(player.position);
            player.sprite.position.y = 1;
            player.sprite.material.rotation = player.rotation;
            
            // CÃ¡mara en tercera persona estilo DOOM (corregida)
            const camDistance = 15;
            const camHeight = 12;
            camera.position.set(
                player.position.x,
                camHeight,
                player.position.z + camDistance
            );
            camera.lookAt(player.position.x, 1, player.position.z);

            // Actualizar HUD
            document.getElementById('health-fill').style.width = player.health + '%';
            document.getElementById('score').textContent = player.score;

            // Dibujar minimapa
            drawMinimap();

            // Limpiar enemigos desconectados
            const now_time = Date.now();
            enemies.forEach((enemy, id) => {
                if (now_time - enemy.lastUpdate > 2000) {
                    scene.remove(enemy.sprite);
                    enemies.delete(id);
                }
            });

            renderer.render(scene, camera);
        }

        // FunciÃ³n para dibujar el minimapa
        function drawMinimap() {
            const canvas = document.getElementById('minimap');
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, 200, 200);
            
            // Dibujar bordes
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, 200, 200);
            
            // Dibujar jugador local
            ctx.fillStyle = '#00ff00';
            ctx.beginPath();
            ctx.arc(100 + player.position.x * 5, 100 + player.position.z * 5, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Dibujar direcciÃ³n del jugador
            ctx.strokeStyle = '#00ff00';
            ctx.beginPath();
            ctx.moveTo(100 + player.position.x * 5, 100 + player.position.z * 5);
            ctx.lineTo(
                100 + (player.position.x + Math.sin(player.rotation) * 3) * 5,
                100 + (player.position.z + Math.cos(player.rotation) * 3) * 5
            );
            ctx.stroke();
            
            // Dibujar enemigos
            enemies.forEach((enemy) => {
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(100 + enemy.sprite.position.x * 5, 100 + enemy.sprite.position.z * 5, 4, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        animate();

        // Ajustar tamaÃ±o
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Sistema de daÃ±o
        setInterval(() => {
            enemies.forEach((enemy) => {
                if (player.position.distanceTo(enemy.sprite.position) < 2) {
                    player.health = Math.max(0, player.health - 2);
                }
            });
        }, 200);
    </script>
</body>
</html>
